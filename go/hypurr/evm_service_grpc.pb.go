// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             v3.21.12
// source: hypurr/evm_service.proto

package hypurr

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	EVM_ERC20Token_FullMethodName          = "/hypurr.EVM/ERC20Token"
	EVM_ERC20Tokens_FullMethodName         = "/hypurr.EVM/ERC20Tokens"
	EVM_UniV2Pair_FullMethodName           = "/hypurr.EVM/UniV2Pair"
	EVM_UniV2Pairs_FullMethodName          = "/hypurr.EVM/UniV2Pairs"
	EVM_UniV2Swap_FullMethodName           = "/hypurr.EVM/UniV2Swap"
	EVM_UniV2Swaps_FullMethodName          = "/hypurr.EVM/UniV2Swaps"
	EVM_ERC20TransferEvents_FullMethodName = "/hypurr.EVM/ERC20TransferEvents"
	EVM_ERC20ApprovalEvents_FullMethodName = "/hypurr.EVM/ERC20ApprovalEvents"
	EVM_UniV2Candles_FullMethodName        = "/hypurr.EVM/UniV2Candles"
)

// EVMClient is the client API for EVM service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EVMClient interface {
	// Token related endpoints
	ERC20Token(ctx context.Context, in *ERC20TokenRequest, opts ...grpc.CallOption) (*ERC20TokenResponse, error)
	ERC20Tokens(ctx context.Context, in *ERC20TokensRequest, opts ...grpc.CallOption) (*ERC20TokensResponse, error)
	// Pair related endpoints
	UniV2Pair(ctx context.Context, in *UniV2PairRequest, opts ...grpc.CallOption) (*UniV2PairResponse, error)
	UniV2Pairs(ctx context.Context, in *UniV2PairsRequest, opts ...grpc.CallOption) (*UniV2PairsResponse, error)
	// Swap related endpoints
	UniV2Swap(ctx context.Context, in *UniV2SwapRequest, opts ...grpc.CallOption) (*UniV2SwapResponse, error)
	UniV2Swaps(ctx context.Context, in *UniV2SwapsRequest, opts ...grpc.CallOption) (*UniV2SwapsResponse, error)
	// Event related endpoints
	ERC20TransferEvents(ctx context.Context, in *ERC20TransferEventsRequest, opts ...grpc.CallOption) (*ERC20TransferEventsResponse, error)
	ERC20ApprovalEvents(ctx context.Context, in *ERC20ApprovalEventsRequest, opts ...grpc.CallOption) (*ERC20ApprovalEventsResponse, error)
	// Price candle related endpoints
	UniV2Candles(ctx context.Context, in *UniV2CandlesRequest, opts ...grpc.CallOption) (*UniV2CandlesResponse, error)
}

type eVMClient struct {
	cc grpc.ClientConnInterface
}

func NewEVMClient(cc grpc.ClientConnInterface) EVMClient {
	return &eVMClient{cc}
}

func (c *eVMClient) ERC20Token(ctx context.Context, in *ERC20TokenRequest, opts ...grpc.CallOption) (*ERC20TokenResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ERC20TokenResponse)
	err := c.cc.Invoke(ctx, EVM_ERC20Token_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) ERC20Tokens(ctx context.Context, in *ERC20TokensRequest, opts ...grpc.CallOption) (*ERC20TokensResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ERC20TokensResponse)
	err := c.cc.Invoke(ctx, EVM_ERC20Tokens_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) UniV2Pair(ctx context.Context, in *UniV2PairRequest, opts ...grpc.CallOption) (*UniV2PairResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniV2PairResponse)
	err := c.cc.Invoke(ctx, EVM_UniV2Pair_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) UniV2Pairs(ctx context.Context, in *UniV2PairsRequest, opts ...grpc.CallOption) (*UniV2PairsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniV2PairsResponse)
	err := c.cc.Invoke(ctx, EVM_UniV2Pairs_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) UniV2Swap(ctx context.Context, in *UniV2SwapRequest, opts ...grpc.CallOption) (*UniV2SwapResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniV2SwapResponse)
	err := c.cc.Invoke(ctx, EVM_UniV2Swap_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) UniV2Swaps(ctx context.Context, in *UniV2SwapsRequest, opts ...grpc.CallOption) (*UniV2SwapsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniV2SwapsResponse)
	err := c.cc.Invoke(ctx, EVM_UniV2Swaps_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) ERC20TransferEvents(ctx context.Context, in *ERC20TransferEventsRequest, opts ...grpc.CallOption) (*ERC20TransferEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ERC20TransferEventsResponse)
	err := c.cc.Invoke(ctx, EVM_ERC20TransferEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) ERC20ApprovalEvents(ctx context.Context, in *ERC20ApprovalEventsRequest, opts ...grpc.CallOption) (*ERC20ApprovalEventsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ERC20ApprovalEventsResponse)
	err := c.cc.Invoke(ctx, EVM_ERC20ApprovalEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eVMClient) UniV2Candles(ctx context.Context, in *UniV2CandlesRequest, opts ...grpc.CallOption) (*UniV2CandlesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UniV2CandlesResponse)
	err := c.cc.Invoke(ctx, EVM_UniV2Candles_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EVMServer is the server API for EVM service.
// All implementations must embed UnimplementedEVMServer
// for forward compatibility
type EVMServer interface {
	// Token related endpoints
	ERC20Token(context.Context, *ERC20TokenRequest) (*ERC20TokenResponse, error)
	ERC20Tokens(context.Context, *ERC20TokensRequest) (*ERC20TokensResponse, error)
	// Pair related endpoints
	UniV2Pair(context.Context, *UniV2PairRequest) (*UniV2PairResponse, error)
	UniV2Pairs(context.Context, *UniV2PairsRequest) (*UniV2PairsResponse, error)
	// Swap related endpoints
	UniV2Swap(context.Context, *UniV2SwapRequest) (*UniV2SwapResponse, error)
	UniV2Swaps(context.Context, *UniV2SwapsRequest) (*UniV2SwapsResponse, error)
	// Event related endpoints
	ERC20TransferEvents(context.Context, *ERC20TransferEventsRequest) (*ERC20TransferEventsResponse, error)
	ERC20ApprovalEvents(context.Context, *ERC20ApprovalEventsRequest) (*ERC20ApprovalEventsResponse, error)
	// Price candle related endpoints
	UniV2Candles(context.Context, *UniV2CandlesRequest) (*UniV2CandlesResponse, error)
	mustEmbedUnimplementedEVMServer()
}

// UnimplementedEVMServer must be embedded to have forward compatible implementations.
type UnimplementedEVMServer struct {
}

func (UnimplementedEVMServer) ERC20Token(context.Context, *ERC20TokenRequest) (*ERC20TokenResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ERC20Token not implemented")
}
func (UnimplementedEVMServer) ERC20Tokens(context.Context, *ERC20TokensRequest) (*ERC20TokensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ERC20Tokens not implemented")
}
func (UnimplementedEVMServer) UniV2Pair(context.Context, *UniV2PairRequest) (*UniV2PairResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniV2Pair not implemented")
}
func (UnimplementedEVMServer) UniV2Pairs(context.Context, *UniV2PairsRequest) (*UniV2PairsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniV2Pairs not implemented")
}
func (UnimplementedEVMServer) UniV2Swap(context.Context, *UniV2SwapRequest) (*UniV2SwapResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniV2Swap not implemented")
}
func (UnimplementedEVMServer) UniV2Swaps(context.Context, *UniV2SwapsRequest) (*UniV2SwapsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniV2Swaps not implemented")
}
func (UnimplementedEVMServer) ERC20TransferEvents(context.Context, *ERC20TransferEventsRequest) (*ERC20TransferEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ERC20TransferEvents not implemented")
}
func (UnimplementedEVMServer) ERC20ApprovalEvents(context.Context, *ERC20ApprovalEventsRequest) (*ERC20ApprovalEventsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ERC20ApprovalEvents not implemented")
}
func (UnimplementedEVMServer) UniV2Candles(context.Context, *UniV2CandlesRequest) (*UniV2CandlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UniV2Candles not implemented")
}
func (UnimplementedEVMServer) mustEmbedUnimplementedEVMServer() {}

// UnsafeEVMServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EVMServer will
// result in compilation errors.
type UnsafeEVMServer interface {
	mustEmbedUnimplementedEVMServer()
}

func RegisterEVMServer(s grpc.ServiceRegistrar, srv EVMServer) {
	s.RegisterService(&EVM_ServiceDesc, srv)
}

func _EVM_ERC20Token_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20TokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).ERC20Token(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_ERC20Token_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).ERC20Token(ctx, req.(*ERC20TokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_ERC20Tokens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20TokensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).ERC20Tokens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_ERC20Tokens_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).ERC20Tokens(ctx, req.(*ERC20TokensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_UniV2Pair_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniV2PairRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).UniV2Pair(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_UniV2Pair_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).UniV2Pair(ctx, req.(*UniV2PairRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_UniV2Pairs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniV2PairsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).UniV2Pairs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_UniV2Pairs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).UniV2Pairs(ctx, req.(*UniV2PairsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_UniV2Swap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniV2SwapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).UniV2Swap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_UniV2Swap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).UniV2Swap(ctx, req.(*UniV2SwapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_UniV2Swaps_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniV2SwapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).UniV2Swaps(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_UniV2Swaps_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).UniV2Swaps(ctx, req.(*UniV2SwapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_ERC20TransferEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20TransferEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).ERC20TransferEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_ERC20TransferEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).ERC20TransferEvents(ctx, req.(*ERC20TransferEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_ERC20ApprovalEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ERC20ApprovalEventsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).ERC20ApprovalEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_ERC20ApprovalEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).ERC20ApprovalEvents(ctx, req.(*ERC20ApprovalEventsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EVM_UniV2Candles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UniV2CandlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EVMServer).UniV2Candles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EVM_UniV2Candles_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EVMServer).UniV2Candles(ctx, req.(*UniV2CandlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// EVM_ServiceDesc is the grpc.ServiceDesc for EVM service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EVM_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "hypurr.EVM",
	HandlerType: (*EVMServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ERC20Token",
			Handler:    _EVM_ERC20Token_Handler,
		},
		{
			MethodName: "ERC20Tokens",
			Handler:    _EVM_ERC20Tokens_Handler,
		},
		{
			MethodName: "UniV2Pair",
			Handler:    _EVM_UniV2Pair_Handler,
		},
		{
			MethodName: "UniV2Pairs",
			Handler:    _EVM_UniV2Pairs_Handler,
		},
		{
			MethodName: "UniV2Swap",
			Handler:    _EVM_UniV2Swap_Handler,
		},
		{
			MethodName: "UniV2Swaps",
			Handler:    _EVM_UniV2Swaps_Handler,
		},
		{
			MethodName: "ERC20TransferEvents",
			Handler:    _EVM_ERC20TransferEvents_Handler,
		},
		{
			MethodName: "ERC20ApprovalEvents",
			Handler:    _EVM_ERC20ApprovalEvents_Handler,
		},
		{
			MethodName: "UniV2Candles",
			Handler:    _EVM_UniV2Candles_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "hypurr/evm_service.proto",
}
