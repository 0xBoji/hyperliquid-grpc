// @generated by protobuf-ts 2.8.2 with parameter long_type_number
// @generated from protobuf file "hypurr/evm.proto" (package "hypurr", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * ERC20 Token messages
 *
 * @generated from protobuf message hypurr.ERC20Token
 */
export interface ERC20Token {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: string name = 2;
     */
    name: string;
    /**
     * @generated from protobuf field: string symbol = 3;
     */
    symbol: string;
    /**
     * @generated from protobuf field: int32 decimals = 4;
     */
    decimals: number;
    /**
     * @generated from protobuf field: string total_supply = 5;
     */
    totalSupply: string; // Using string for big integers
    /**
     * @generated from protobuf field: double price_in_whype = 6;
     */
    priceInWhype: number; // New field for price in WHYPE
    /**
     * @generated from protobuf field: double volume_in_whype = 7;
     */
    volumeInWhype: number; // Added field for volume in WHYPE
    /**
     * @generated from protobuf field: int64 last_volume_update = 8;
     */
    lastVolumeUpdate: number;
}
/**
 * Account Balance messages
 *
 * @generated from protobuf message hypurr.ERC20AccountBalance
 */
export interface ERC20AccountBalance {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: string contract = 2;
     */
    contract: string;
    /**
     * @generated from protobuf field: string balance = 3;
     */
    balance: string; // Using string for big integers
    /**
     * @generated from protobuf field: bool is_owner = 4;
     */
    isOwner: boolean;
}
/**
 * UniswapV2 Pair messages
 *
 * @generated from protobuf message hypurr.UniV2Pair
 */
export interface UniV2Pair {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
    /**
     * @generated from protobuf field: hypurr.ERC20Token token0 = 2;
     */
    token0?: ERC20Token; // Embedded token object
    /**
     * @generated from protobuf field: hypurr.ERC20Token token1 = 3;
     */
    token1?: ERC20Token; // Embedded token object
    /**
     * @generated from protobuf field: string reserve0 = 4;
     */
    reserve0: string; // Using string for big integers
    /**
     * @generated from protobuf field: string reserve1 = 5;
     */
    reserve1: string; // Using string for big integers
    /**
     * @generated from protobuf field: string total_supply = 6;
     */
    totalSupply: string; // Using string for big integers
    /**
     * @generated from protobuf field: string factory = 7;
     */
    factory: string;
}
/**
 * Swap messages
 *
 * @generated from protobuf message hypurr.UniV2Swap
 */
export interface UniV2Swap {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string pair = 2;
     */
    pair: string;
    /**
     * @generated from protobuf field: string sender = 3;
     */
    sender: string;
    /**
     * @generated from protobuf field: string amount0_in = 4;
     */
    amount0In: string; // Using string for big integers
    /**
     * @generated from protobuf field: string amount1_in = 5;
     */
    amount1In: string; // Using string for big integers
    /**
     * @generated from protobuf field: string amount0_out = 6;
     */
    amount0Out: string; // Using string for big integers
    /**
     * @generated from protobuf field: string amount1_out = 7;
     */
    amount1Out: string; // Using string for big integers
    /**
     * @generated from protobuf field: string to = 8;
     */
    to: string;
    /**
     * @generated from protobuf field: int64 timestamp = 9;
     */
    timestamp: number;
}
/**
 * ERC20 Transfer Event messages
 *
 * @generated from protobuf message hypurr.ERC20TransferEvent
 */
export interface ERC20TransferEvent {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string contract = 2;
     */
    contract: string;
    /**
     * @generated from protobuf field: string amount = 3;
     */
    amount: string; // Using string for big integers
    /**
     * @generated from protobuf field: int64 timestamp = 4;
     */
    timestamp: number;
    /**
     * @generated from protobuf field: string from = 5;
     */
    from: string;
    /**
     * @generated from protobuf field: string to = 6;
     */
    to: string;
}
/**
 * ERC20 Approval Event messages
 *
 * @generated from protobuf message hypurr.ERC20ApprovalEvent
 */
export interface ERC20ApprovalEvent {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
    /**
     * @generated from protobuf field: string contract = 2;
     */
    contract: string;
    /**
     * @generated from protobuf field: string amount = 3;
     */
    amount: string; // Using string for big integers
    /**
     * @generated from protobuf field: int64 timestamp = 4;
     */
    timestamp: number;
    /**
     * @generated from protobuf field: string owner = 5;
     */
    owner: string;
    /**
     * @generated from protobuf field: string spender = 6;
     */
    spender: string;
}
/**
 * ERC20 Allowance messages
 *
 * @generated from protobuf message hypurr.ERC20Allowance
 */
export interface ERC20Allowance {
    /**
     * @generated from protobuf field: string owner = 1;
     */
    owner: string;
    /**
     * @generated from protobuf field: string spender = 2;
     */
    spender: string;
    /**
     * @generated from protobuf field: string amount = 3;
     */
    amount: string; // Using string for big integers
}
/**
 * UniV2 Price Candle messages
 *
 * @generated from protobuf message hypurr.UniV2Candle
 */
export interface UniV2Candle {
    /**
     * @generated from protobuf field: int64 timestamp = 1;
     */
    timestamp: number;
    /**
     * @generated from protobuf field: double open = 2;
     */
    open: number;
    /**
     * @generated from protobuf field: double high = 3;
     */
    high: number;
    /**
     * @generated from protobuf field: double low = 4;
     */
    low: number;
    /**
     * @generated from protobuf field: double close = 5;
     */
    close: number;
    /**
     * @generated from protobuf field: string volume_token0 = 6;
     */
    volumeToken0: string; // Using string for big integers
    /**
     * @generated from protobuf field: string volume_token1 = 7;
     */
    volumeToken1: string; // Using string for big integers
}
// @generated message type with reflection information, may provide speed optimized methods
class ERC20Token$Type extends MessageType<ERC20Token> {
    constructor() {
        super("hypurr.ERC20Token", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "symbol", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "decimals", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "total_supply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "price_in_whype", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 7, name: "volume_in_whype", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 8, name: "last_volume_update", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20Token>): ERC20Token {
        const message = { address: "", name: "", symbol: "", decimals: 0, totalSupply: "", priceInWhype: 0, volumeInWhype: 0, lastVolumeUpdate: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20Token>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20Token): ERC20Token {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string symbol */ 3:
                    message.symbol = reader.string();
                    break;
                case /* int32 decimals */ 4:
                    message.decimals = reader.int32();
                    break;
                case /* string total_supply */ 5:
                    message.totalSupply = reader.string();
                    break;
                case /* double price_in_whype */ 6:
                    message.priceInWhype = reader.double();
                    break;
                case /* double volume_in_whype */ 7:
                    message.volumeInWhype = reader.double();
                    break;
                case /* int64 last_volume_update */ 8:
                    message.lastVolumeUpdate = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20Token, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string symbol = 3; */
        if (message.symbol !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.symbol);
        /* int32 decimals = 4; */
        if (message.decimals !== 0)
            writer.tag(4, WireType.Varint).int32(message.decimals);
        /* string total_supply = 5; */
        if (message.totalSupply !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.totalSupply);
        /* double price_in_whype = 6; */
        if (message.priceInWhype !== 0)
            writer.tag(6, WireType.Bit64).double(message.priceInWhype);
        /* double volume_in_whype = 7; */
        if (message.volumeInWhype !== 0)
            writer.tag(7, WireType.Bit64).double(message.volumeInWhype);
        /* int64 last_volume_update = 8; */
        if (message.lastVolumeUpdate !== 0)
            writer.tag(8, WireType.Varint).int64(message.lastVolumeUpdate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20Token
 */
export const ERC20Token = new ERC20Token$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20AccountBalance$Type extends MessageType<ERC20AccountBalance> {
    constructor() {
        super("hypurr.ERC20AccountBalance", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "balance", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "is_owner", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20AccountBalance>): ERC20AccountBalance {
        const message = { address: "", contract: "", balance: "", isOwner: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20AccountBalance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20AccountBalance): ERC20AccountBalance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* string balance */ 3:
                    message.balance = reader.string();
                    break;
                case /* bool is_owner */ 4:
                    message.isOwner = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20AccountBalance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* string balance = 3; */
        if (message.balance !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.balance);
        /* bool is_owner = 4; */
        if (message.isOwner !== false)
            writer.tag(4, WireType.Varint).bool(message.isOwner);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20AccountBalance
 */
export const ERC20AccountBalance = new ERC20AccountBalance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2Pair$Type extends MessageType<UniV2Pair> {
    constructor() {
        super("hypurr.UniV2Pair", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "token0", kind: "message", T: () => ERC20Token },
            { no: 3, name: "token1", kind: "message", T: () => ERC20Token },
            { no: 4, name: "reserve0", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "reserve1", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "total_supply", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "factory", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2Pair>): UniV2Pair {
        const message = { address: "", reserve0: "", reserve1: "", totalSupply: "", factory: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2Pair>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2Pair): UniV2Pair {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* hypurr.ERC20Token token0 */ 2:
                    message.token0 = ERC20Token.internalBinaryRead(reader, reader.uint32(), options, message.token0);
                    break;
                case /* hypurr.ERC20Token token1 */ 3:
                    message.token1 = ERC20Token.internalBinaryRead(reader, reader.uint32(), options, message.token1);
                    break;
                case /* string reserve0 */ 4:
                    message.reserve0 = reader.string();
                    break;
                case /* string reserve1 */ 5:
                    message.reserve1 = reader.string();
                    break;
                case /* string total_supply */ 6:
                    message.totalSupply = reader.string();
                    break;
                case /* string factory */ 7:
                    message.factory = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2Pair, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* hypurr.ERC20Token token0 = 2; */
        if (message.token0)
            ERC20Token.internalBinaryWrite(message.token0, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* hypurr.ERC20Token token1 = 3; */
        if (message.token1)
            ERC20Token.internalBinaryWrite(message.token1, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* string reserve0 = 4; */
        if (message.reserve0 !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.reserve0);
        /* string reserve1 = 5; */
        if (message.reserve1 !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.reserve1);
        /* string total_supply = 6; */
        if (message.totalSupply !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.totalSupply);
        /* string factory = 7; */
        if (message.factory !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.factory);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2Pair
 */
export const UniV2Pair = new UniV2Pair$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2Swap$Type extends MessageType<UniV2Swap> {
    constructor() {
        super("hypurr.UniV2Swap", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "pair", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "sender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "amount0_in", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "amount1_in", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "amount0_out", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "amount1_out", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2Swap>): UniV2Swap {
        const message = { id: "", pair: "", sender: "", amount0In: "", amount1In: "", amount0Out: "", amount1Out: "", to: "", timestamp: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2Swap>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2Swap): UniV2Swap {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string pair */ 2:
                    message.pair = reader.string();
                    break;
                case /* string sender */ 3:
                    message.sender = reader.string();
                    break;
                case /* string amount0_in */ 4:
                    message.amount0In = reader.string();
                    break;
                case /* string amount1_in */ 5:
                    message.amount1In = reader.string();
                    break;
                case /* string amount0_out */ 6:
                    message.amount0Out = reader.string();
                    break;
                case /* string amount1_out */ 7:
                    message.amount1Out = reader.string();
                    break;
                case /* string to */ 8:
                    message.to = reader.string();
                    break;
                case /* int64 timestamp */ 9:
                    message.timestamp = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2Swap, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string pair = 2; */
        if (message.pair !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pair);
        /* string sender = 3; */
        if (message.sender !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.sender);
        /* string amount0_in = 4; */
        if (message.amount0In !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.amount0In);
        /* string amount1_in = 5; */
        if (message.amount1In !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount1In);
        /* string amount0_out = 6; */
        if (message.amount0Out !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.amount0Out);
        /* string amount1_out = 7; */
        if (message.amount1Out !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.amount1Out);
        /* string to = 8; */
        if (message.to !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.to);
        /* int64 timestamp = 9; */
        if (message.timestamp !== 0)
            writer.tag(9, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2Swap
 */
export const UniV2Swap = new UniV2Swap$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TransferEvent$Type extends MessageType<ERC20TransferEvent> {
    constructor() {
        super("hypurr.ERC20TransferEvent", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "from", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "to", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TransferEvent>): ERC20TransferEvent {
        const message = { id: "", contract: "", amount: "", timestamp: 0, from: "", to: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TransferEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TransferEvent): ERC20TransferEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toNumber();
                    break;
                case /* string from */ 5:
                    message.from = reader.string();
                    break;
                case /* string to */ 6:
                    message.to = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TransferEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        /* string from = 5; */
        if (message.from !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.from);
        /* string to = 6; */
        if (message.to !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.to);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TransferEvent
 */
export const ERC20TransferEvent = new ERC20TransferEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20ApprovalEvent$Type extends MessageType<ERC20ApprovalEvent> {
    constructor() {
        super("hypurr.ERC20ApprovalEvent", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "contract", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 5, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "spender", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20ApprovalEvent>): ERC20ApprovalEvent {
        const message = { id: "", contract: "", amount: "", timestamp: 0, owner: "", spender: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20ApprovalEvent>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20ApprovalEvent): ERC20ApprovalEvent {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string contract */ 2:
                    message.contract = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toNumber();
                    break;
                case /* string owner */ 5:
                    message.owner = reader.string();
                    break;
                case /* string spender */ 6:
                    message.spender = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20ApprovalEvent, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string contract = 2; */
        if (message.contract !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.contract);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        /* string owner = 5; */
        if (message.owner !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.owner);
        /* string spender = 6; */
        if (message.spender !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.spender);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20ApprovalEvent
 */
export const ERC20ApprovalEvent = new ERC20ApprovalEvent$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20Allowance$Type extends MessageType<ERC20Allowance> {
    constructor() {
        super("hypurr.ERC20Allowance", [
            { no: 1, name: "owner", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "spender", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20Allowance>): ERC20Allowance {
        const message = { owner: "", spender: "", amount: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20Allowance>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20Allowance): ERC20Allowance {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string owner */ 1:
                    message.owner = reader.string();
                    break;
                case /* string spender */ 2:
                    message.spender = reader.string();
                    break;
                case /* string amount */ 3:
                    message.amount = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20Allowance, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string owner = 1; */
        if (message.owner !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.owner);
        /* string spender = 2; */
        if (message.spender !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.spender);
        /* string amount = 3; */
        if (message.amount !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20Allowance
 */
export const ERC20Allowance = new ERC20Allowance$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2Candle$Type extends MessageType<UniV2Candle> {
    constructor() {
        super("hypurr.UniV2Candle", [
            { no: 1, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "open", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "high", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "low", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "close", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 6, name: "volume_token0", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "volume_token1", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2Candle>): UniV2Candle {
        const message = { timestamp: 0, open: 0, high: 0, low: 0, close: 0, volumeToken0: "", volumeToken1: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2Candle>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2Candle): UniV2Candle {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 timestamp */ 1:
                    message.timestamp = reader.int64().toNumber();
                    break;
                case /* double open */ 2:
                    message.open = reader.double();
                    break;
                case /* double high */ 3:
                    message.high = reader.double();
                    break;
                case /* double low */ 4:
                    message.low = reader.double();
                    break;
                case /* double close */ 5:
                    message.close = reader.double();
                    break;
                case /* string volume_token0 */ 6:
                    message.volumeToken0 = reader.string();
                    break;
                case /* string volume_token1 */ 7:
                    message.volumeToken1 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2Candle, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 timestamp = 1; */
        if (message.timestamp !== 0)
            writer.tag(1, WireType.Varint).int64(message.timestamp);
        /* double open = 2; */
        if (message.open !== 0)
            writer.tag(2, WireType.Bit64).double(message.open);
        /* double high = 3; */
        if (message.high !== 0)
            writer.tag(3, WireType.Bit64).double(message.high);
        /* double low = 4; */
        if (message.low !== 0)
            writer.tag(4, WireType.Bit64).double(message.low);
        /* double close = 5; */
        if (message.close !== 0)
            writer.tag(5, WireType.Bit64).double(message.close);
        /* string volume_token0 = 6; */
        if (message.volumeToken0 !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.volumeToken0);
        /* string volume_token1 = 7; */
        if (message.volumeToken1 !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.volumeToken1);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2Candle
 */
export const UniV2Candle = new UniV2Candle$Type();
