// @generated by protobuf-ts 2.8.2 with parameter long_type_number
// @generated from protobuf file "hypurr/telegram_service.proto" (package "hypurr", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { BytesValue } from "../google/protobuf/wrappers";
import { HyperliquidLaunch } from "./launch";
import { HyperliquidWalletSpotTwapSession } from "./tools";
import { HyperliquidSpotSniperConfig } from "./tools";
import { HyperliquidWallet } from "./wallet";
import { TelegramUser } from "./user";
/**
 * Auth endpoints
 *
 * @generated from protobuf message hypurr.TelegramUserRequest
 */
export interface TelegramUserRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message hypurr.TelegramUserResponse
 */
export interface TelegramUserResponse {
    /**
     * @generated from protobuf field: hypurr.TelegramUser user = 1;
     */
    user?: TelegramUser;
}
/**
 * @generated from protobuf message hypurr.TelegramUserWalletsRequest
 */
export interface TelegramUserWalletsRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message hypurr.TelegramUserWalletsResponse
 */
export interface TelegramUserWalletsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWallet wallets = 1;
     */
    wallets: HyperliquidWallet[];
}
/**
 * @generated from protobuf message hypurr.HyperliquidLaunchTradeRequest
 */
export interface HyperliquidLaunchTradeRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 launch_id = 2;
     */
    launchId: number;
    /**
     * @generated from protobuf field: int64 wallet_id = 3;
     */
    walletId: number;
    /**
     * @generated from protobuf field: hypurr.HyperliquidLaunchTradeDirection direction = 4;
     */
    direction: HyperliquidLaunchTradeDirection;
    /**
     * @generated from protobuf field: double amount = 5;
     */
    amount: number;
}
/**
 * @generated from protobuf message hypurr.HyperliquidLaunchTradeResponse
 */
export interface HyperliquidLaunchTradeResponse {
    /**
     * @generated from protobuf field: double base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: double quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
}
/**
 * @generated from protobuf message hypurr.HyperliquidSpotTradeRequest
 */
export interface HyperliquidSpotTradeRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 pair_id = 2;
     */
    pairId: number;
    /**
     * @generated from protobuf field: int64 wallet_id = 3;
     */
    walletId: number;
    /**
     * @generated from protobuf field: hypurr.HyperliquidLaunchTradeDirection direction = 4;
     */
    direction: HyperliquidLaunchTradeDirection;
    /**
     * @generated from protobuf field: double amount = 5;
     */
    amount: number;
}
/**
 * @generated from protobuf message hypurr.HyperliquidSpotTradeResponse
 */
export interface HyperliquidSpotTradeResponse {
    /**
     * @generated from protobuf field: double base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: double quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
}
/**
 * @generated from protobuf message hypurr.HyperliquidSpotSniperConfigsRequest
 */
export interface HyperliquidSpotSniperConfigsRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
}
/**
 * @generated from protobuf message hypurr.HyperliquidSpotSniperConfigsResponse
 */
export interface HyperliquidSpotSniperConfigsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidSpotSniperConfig configs = 1;
     */
    configs: HyperliquidSpotSniperConfig[];
}
/**
 * @generated from protobuf message hypurr.DeleteHyperliquidSpotSniperConfigRequest
 */
export interface DeleteHyperliquidSpotSniperConfigRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 config_id = 2;
     */
    configId: number;
}
/**
 * @generated from protobuf message hypurr.DeleteHyperliquidSpotSniperConfigResponse
 */
export interface DeleteHyperliquidSpotSniperConfigResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
/**
 * @generated from protobuf message hypurr.CreateHyperliquidSpotSniperConfigRequest
 */
export interface CreateHyperliquidSpotSniperConfigRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: hypurr.HyperliquidSpotSniperConfig config = 2;
     */
    config?: HyperliquidSpotSniperConfig;
}
/**
 * @generated from protobuf message hypurr.CreateHyperliquidSpotSniperConfigResponse
 */
export interface CreateHyperliquidSpotSniperConfigResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
    /**
     * @generated from protobuf field: hypurr.HyperliquidSpotSniperConfig config = 2;
     */
    config?: HyperliquidSpotSniperConfig;
}
/**
 * @generated from protobuf message hypurr.UpdateHyperliquidSpotSniperConfigRequest
 */
export interface UpdateHyperliquidSpotSniperConfigRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: hypurr.HyperliquidSpotSniperConfig config = 2;
     */
    config?: HyperliquidSpotSniperConfig;
}
/**
 * @generated from protobuf message hypurr.UpdateHyperliquidSpotSniperConfigResponse
 */
export interface UpdateHyperliquidSpotSniperConfigResponse {
    /**
     * @generated from protobuf field: bool success = 1;
     */
    success: boolean;
}
/**
 * @generated from protobuf message hypurr.HyperliquidWalletSpotTwapSessionsRequest
 */
export interface HyperliquidWalletSpotTwapSessionsRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 wallet_id = 2;
     */
    walletId: number;
}
/**
 * @generated from protobuf message hypurr.HyperliquidWalletSpotTwapSessionsResponse
 */
export interface HyperliquidWalletSpotTwapSessionsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWalletSpotTwapSession sessions = 1;
     */
    sessions: HyperliquidWalletSpotTwapSession[];
}
/**
 * @generated from protobuf message hypurr.LaunchHyperliquidLaunchRequest
 */
export interface LaunchHyperliquidLaunchRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 wallet_id = 2;
     */
    walletId: number;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: string full_name = 4;
     */
    fullName: string;
    /**
     * @generated from protobuf field: string token_name = 5;
     */
    tokenName: string;
    /**
     * @generated from protobuf field: bytes media = 6;
     */
    media: Uint8Array;
    /**
     * @generated from protobuf field: hypurr.MediaType media_type = 7;
     */
    mediaType: MediaType;
    /**
     * @generated from protobuf field: int64 dev_lockup_seconds = 8;
     */
    devLockupSeconds: number;
    /**
     * @generated from protobuf field: double initial_purchase_notional = 9;
     */
    initialPurchaseNotional: number;
}
/**
 * @generated from protobuf message hypurr.LaunchHyperliquidLaunchResponse
 */
export interface LaunchHyperliquidLaunchResponse {
    /**
     * @generated from protobuf field: hypurr.HyperliquidLaunch launch = 1;
     */
    launch?: HyperliquidLaunch;
}
/**
 * @generated from protobuf message hypurr.EditHyperliquidLaunchRequest
 */
export interface EditHyperliquidLaunchRequest {
    /**
     * @generated from protobuf field: map<string, string> auth_data = 1;
     */
    authData: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 launch_id = 2;
     */
    launchId: number;
    /**
     * @generated from protobuf field: string description = 3;
     */
    description: string;
    /**
     * @generated from protobuf field: string full_name = 4;
     */
    fullName: string;
    /**
     * @generated from protobuf field: google.protobuf.BytesValue media = 5;
     */
    media?: BytesValue;
    /**
     * @generated from protobuf field: hypurr.MediaType media_type = 6;
     */
    mediaType: MediaType;
    /**
     * @generated from protobuf field: int64 dev_lockup_seconds = 7;
     */
    devLockupSeconds: number;
}
/**
 * @generated from protobuf message hypurr.EditHyperliquidLaunchResponse
 */
export interface EditHyperliquidLaunchResponse {
    /**
     * @generated from protobuf field: hypurr.HyperliquidLaunch launch = 1;
     */
    launch?: HyperliquidLaunch;
}
/**
 * @generated from protobuf enum hypurr.HyperliquidLaunchTradeDirection
 */
export enum HyperliquidLaunchTradeDirection {
    /**
     * @generated from protobuf enum value: BUY = 0;
     */
    BUY = 0,
    /**
     * @generated from protobuf enum value: SELL = 1;
     */
    SELL = 1
}
/**
 * @generated from protobuf enum hypurr.MediaType
 */
export enum MediaType {
    /**
     * @generated from protobuf enum value: MEDIA_TYPE_PHOTO = 0;
     */
    PHOTO = 0,
    /**
     * @generated from protobuf enum value: MEDIA_TYPE_ANIMATION = 1;
     */
    ANIMATION = 1,
    /**
     * @generated from protobuf enum value: MEDIA_TYPE_VIDEO = 2;
     */
    VIDEO = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserRequest$Type extends MessageType<TelegramUserRequest> {
    constructor() {
        super("hypurr.TelegramUserRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TelegramUserRequest>): TelegramUserRequest {
        const message = { authData: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserRequest): TelegramUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TelegramUserRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TelegramUserRequest["authData"] | undefined, val: TelegramUserRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.TelegramUserRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TelegramUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserRequest
 */
export const TelegramUserRequest = new TelegramUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserResponse$Type extends MessageType<TelegramUserResponse> {
    constructor() {
        super("hypurr.TelegramUserResponse", [
            { no: 1, name: "user", kind: "message", T: () => TelegramUser }
        ]);
    }
    create(value?: PartialMessage<TelegramUserResponse>): TelegramUserResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserResponse): TelegramUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.TelegramUser user */ 1:
                    message.user = TelegramUser.internalBinaryRead(reader, reader.uint32(), options, message.user);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelegramUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.TelegramUser user = 1; */
        if (message.user)
            TelegramUser.internalBinaryWrite(message.user, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserResponse
 */
export const TelegramUserResponse = new TelegramUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserWalletsRequest$Type extends MessageType<TelegramUserWalletsRequest> {
    constructor() {
        super("hypurr.TelegramUserWalletsRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<TelegramUserWalletsRequest>): TelegramUserWalletsRequest {
        const message = { authData: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserWalletsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserWalletsRequest): TelegramUserWalletsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: TelegramUserWalletsRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof TelegramUserWalletsRequest["authData"] | undefined, val: TelegramUserWalletsRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.TelegramUserWalletsRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: TelegramUserWalletsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserWalletsRequest
 */
export const TelegramUserWalletsRequest = new TelegramUserWalletsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserWalletsResponse$Type extends MessageType<TelegramUserWalletsResponse> {
    constructor() {
        super("hypurr.TelegramUserWalletsResponse", [
            { no: 1, name: "wallets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWallet }
        ]);
    }
    create(value?: PartialMessage<TelegramUserWalletsResponse>): TelegramUserWalletsResponse {
        const message = { wallets: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserWalletsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserWalletsResponse): TelegramUserWalletsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.HyperliquidWallet wallets */ 1:
                    message.wallets.push(HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelegramUserWalletsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.HyperliquidWallet wallets = 1; */
        for (let i = 0; i < message.wallets.length; i++)
            HyperliquidWallet.internalBinaryWrite(message.wallets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserWalletsResponse
 */
export const TelegramUserWalletsResponse = new TelegramUserWalletsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidLaunchTradeRequest$Type extends MessageType<HyperliquidLaunchTradeRequest> {
    constructor() {
        super("hypurr.HyperliquidLaunchTradeRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "launch_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "direction", kind: "enum", T: () => ["hypurr.HyperliquidLaunchTradeDirection", HyperliquidLaunchTradeDirection] },
            { no: 5, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidLaunchTradeRequest>): HyperliquidLaunchTradeRequest {
        const message = { authData: {}, launchId: 0, walletId: 0, direction: 0, amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidLaunchTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidLaunchTradeRequest): HyperliquidLaunchTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 launch_id */ 2:
                    message.launchId = reader.int64().toNumber();
                    break;
                case /* int64 wallet_id */ 3:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* hypurr.HyperliquidLaunchTradeDirection direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* double amount */ 5:
                    message.amount = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HyperliquidLaunchTradeRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HyperliquidLaunchTradeRequest["authData"] | undefined, val: HyperliquidLaunchTradeRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidLaunchTradeRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HyperliquidLaunchTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 launch_id = 2; */
        if (message.launchId !== 0)
            writer.tag(2, WireType.Varint).int64(message.launchId);
        /* int64 wallet_id = 3; */
        if (message.walletId !== 0)
            writer.tag(3, WireType.Varint).int64(message.walletId);
        /* hypurr.HyperliquidLaunchTradeDirection direction = 4; */
        if (message.direction !== 0)
            writer.tag(4, WireType.Varint).int32(message.direction);
        /* double amount = 5; */
        if (message.amount !== 0)
            writer.tag(5, WireType.Bit64).double(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidLaunchTradeRequest
 */
export const HyperliquidLaunchTradeRequest = new HyperliquidLaunchTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidLaunchTradeResponse$Type extends MessageType<HyperliquidLaunchTradeResponse> {
    constructor() {
        super("hypurr.HyperliquidLaunchTradeResponse", [
            { no: 1, name: "base_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidLaunchTradeResponse>): HyperliquidLaunchTradeResponse {
        const message = { baseAmount: 0, quoteAmount: 0, message: "", success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidLaunchTradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidLaunchTradeResponse): HyperliquidLaunchTradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double base_amount */ 1:
                    message.baseAmount = reader.double();
                    break;
                case /* double quote_amount */ 2:
                    message.quoteAmount = reader.double();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidLaunchTradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Bit64).double(message.baseAmount);
        /* double quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Bit64).double(message.quoteAmount);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidLaunchTradeResponse
 */
export const HyperliquidLaunchTradeResponse = new HyperliquidLaunchTradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotTradeRequest$Type extends MessageType<HyperliquidSpotTradeRequest> {
    constructor() {
        super("hypurr.HyperliquidSpotTradeRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "pair_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "direction", kind: "enum", T: () => ["hypurr.HyperliquidLaunchTradeDirection", HyperliquidLaunchTradeDirection] },
            { no: 5, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotTradeRequest>): HyperliquidSpotTradeRequest {
        const message = { authData: {}, pairId: 0, walletId: 0, direction: 0, amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotTradeRequest): HyperliquidSpotTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 pair_id */ 2:
                    message.pairId = reader.int64().toNumber();
                    break;
                case /* int64 wallet_id */ 3:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* hypurr.HyperliquidLaunchTradeDirection direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* double amount */ 5:
                    message.amount = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HyperliquidSpotTradeRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HyperliquidSpotTradeRequest["authData"] | undefined, val: HyperliquidSpotTradeRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidSpotTradeRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HyperliquidSpotTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 pair_id = 2; */
        if (message.pairId !== 0)
            writer.tag(2, WireType.Varint).int64(message.pairId);
        /* int64 wallet_id = 3; */
        if (message.walletId !== 0)
            writer.tag(3, WireType.Varint).int64(message.walletId);
        /* hypurr.HyperliquidLaunchTradeDirection direction = 4; */
        if (message.direction !== 0)
            writer.tag(4, WireType.Varint).int32(message.direction);
        /* double amount = 5; */
        if (message.amount !== 0)
            writer.tag(5, WireType.Bit64).double(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidSpotTradeRequest
 */
export const HyperliquidSpotTradeRequest = new HyperliquidSpotTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotTradeResponse$Type extends MessageType<HyperliquidSpotTradeResponse> {
    constructor() {
        super("hypurr.HyperliquidSpotTradeResponse", [
            { no: 1, name: "base_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotTradeResponse>): HyperliquidSpotTradeResponse {
        const message = { baseAmount: 0, quoteAmount: 0, message: "", success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotTradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotTradeResponse): HyperliquidSpotTradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double base_amount */ 1:
                    message.baseAmount = reader.double();
                    break;
                case /* double quote_amount */ 2:
                    message.quoteAmount = reader.double();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidSpotTradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Bit64).double(message.baseAmount);
        /* double quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Bit64).double(message.quoteAmount);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidSpotTradeResponse
 */
export const HyperliquidSpotTradeResponse = new HyperliquidSpotTradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotSniperConfigsRequest$Type extends MessageType<HyperliquidSpotSniperConfigsRequest> {
    constructor() {
        super("hypurr.HyperliquidSpotSniperConfigsRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotSniperConfigsRequest>): HyperliquidSpotSniperConfigsRequest {
        const message = { authData: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotSniperConfigsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotSniperConfigsRequest): HyperliquidSpotSniperConfigsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HyperliquidSpotSniperConfigsRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HyperliquidSpotSniperConfigsRequest["authData"] | undefined, val: HyperliquidSpotSniperConfigsRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidSpotSniperConfigsRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HyperliquidSpotSniperConfigsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidSpotSniperConfigsRequest
 */
export const HyperliquidSpotSniperConfigsRequest = new HyperliquidSpotSniperConfigsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotSniperConfigsResponse$Type extends MessageType<HyperliquidSpotSniperConfigsResponse> {
    constructor() {
        super("hypurr.HyperliquidSpotSniperConfigsResponse", [
            { no: 1, name: "configs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidSpotSniperConfig }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotSniperConfigsResponse>): HyperliquidSpotSniperConfigsResponse {
        const message = { configs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotSniperConfigsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotSniperConfigsResponse): HyperliquidSpotSniperConfigsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.HyperliquidSpotSniperConfig configs */ 1:
                    message.configs.push(HyperliquidSpotSniperConfig.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidSpotSniperConfigsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.HyperliquidSpotSniperConfig configs = 1; */
        for (let i = 0; i < message.configs.length; i++)
            HyperliquidSpotSniperConfig.internalBinaryWrite(message.configs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidSpotSniperConfigsResponse
 */
export const HyperliquidSpotSniperConfigsResponse = new HyperliquidSpotSniperConfigsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteHyperliquidSpotSniperConfigRequest$Type extends MessageType<DeleteHyperliquidSpotSniperConfigRequest> {
    constructor() {
        super("hypurr.DeleteHyperliquidSpotSniperConfigRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "config_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteHyperliquidSpotSniperConfigRequest>): DeleteHyperliquidSpotSniperConfigRequest {
        const message = { authData: {}, configId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteHyperliquidSpotSniperConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteHyperliquidSpotSniperConfigRequest): DeleteHyperliquidSpotSniperConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 config_id */ 2:
                    message.configId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: DeleteHyperliquidSpotSniperConfigRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof DeleteHyperliquidSpotSniperConfigRequest["authData"] | undefined, val: DeleteHyperliquidSpotSniperConfigRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.DeleteHyperliquidSpotSniperConfigRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: DeleteHyperliquidSpotSniperConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 config_id = 2; */
        if (message.configId !== 0)
            writer.tag(2, WireType.Varint).int64(message.configId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.DeleteHyperliquidSpotSniperConfigRequest
 */
export const DeleteHyperliquidSpotSniperConfigRequest = new DeleteHyperliquidSpotSniperConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteHyperliquidSpotSniperConfigResponse$Type extends MessageType<DeleteHyperliquidSpotSniperConfigResponse> {
    constructor() {
        super("hypurr.DeleteHyperliquidSpotSniperConfigResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteHyperliquidSpotSniperConfigResponse>): DeleteHyperliquidSpotSniperConfigResponse {
        const message = { success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DeleteHyperliquidSpotSniperConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteHyperliquidSpotSniperConfigResponse): DeleteHyperliquidSpotSniperConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteHyperliquidSpotSniperConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.DeleteHyperliquidSpotSniperConfigResponse
 */
export const DeleteHyperliquidSpotSniperConfigResponse = new DeleteHyperliquidSpotSniperConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateHyperliquidSpotSniperConfigRequest$Type extends MessageType<CreateHyperliquidSpotSniperConfigRequest> {
    constructor() {
        super("hypurr.CreateHyperliquidSpotSniperConfigRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "config", kind: "message", T: () => HyperliquidSpotSniperConfig }
        ]);
    }
    create(value?: PartialMessage<CreateHyperliquidSpotSniperConfigRequest>): CreateHyperliquidSpotSniperConfigRequest {
        const message = { authData: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateHyperliquidSpotSniperConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateHyperliquidSpotSniperConfigRequest): CreateHyperliquidSpotSniperConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* hypurr.HyperliquidSpotSniperConfig config */ 2:
                    message.config = HyperliquidSpotSniperConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: CreateHyperliquidSpotSniperConfigRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof CreateHyperliquidSpotSniperConfigRequest["authData"] | undefined, val: CreateHyperliquidSpotSniperConfigRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.CreateHyperliquidSpotSniperConfigRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: CreateHyperliquidSpotSniperConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* hypurr.HyperliquidSpotSniperConfig config = 2; */
        if (message.config)
            HyperliquidSpotSniperConfig.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.CreateHyperliquidSpotSniperConfigRequest
 */
export const CreateHyperliquidSpotSniperConfigRequest = new CreateHyperliquidSpotSniperConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateHyperliquidSpotSniperConfigResponse$Type extends MessageType<CreateHyperliquidSpotSniperConfigResponse> {
    constructor() {
        super("hypurr.CreateHyperliquidSpotSniperConfigResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "config", kind: "message", T: () => HyperliquidSpotSniperConfig }
        ]);
    }
    create(value?: PartialMessage<CreateHyperliquidSpotSniperConfigResponse>): CreateHyperliquidSpotSniperConfigResponse {
        const message = { success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CreateHyperliquidSpotSniperConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateHyperliquidSpotSniperConfigResponse): CreateHyperliquidSpotSniperConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* hypurr.HyperliquidSpotSniperConfig config */ 2:
                    message.config = HyperliquidSpotSniperConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateHyperliquidSpotSniperConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* hypurr.HyperliquidSpotSniperConfig config = 2; */
        if (message.config)
            HyperliquidSpotSniperConfig.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.CreateHyperliquidSpotSniperConfigResponse
 */
export const CreateHyperliquidSpotSniperConfigResponse = new CreateHyperliquidSpotSniperConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateHyperliquidSpotSniperConfigRequest$Type extends MessageType<UpdateHyperliquidSpotSniperConfigRequest> {
    constructor() {
        super("hypurr.UpdateHyperliquidSpotSniperConfigRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "config", kind: "message", T: () => HyperliquidSpotSniperConfig }
        ]);
    }
    create(value?: PartialMessage<UpdateHyperliquidSpotSniperConfigRequest>): UpdateHyperliquidSpotSniperConfigRequest {
        const message = { authData: {} };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateHyperliquidSpotSniperConfigRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateHyperliquidSpotSniperConfigRequest): UpdateHyperliquidSpotSniperConfigRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* hypurr.HyperliquidSpotSniperConfig config */ 2:
                    message.config = HyperliquidSpotSniperConfig.internalBinaryRead(reader, reader.uint32(), options, message.config);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: UpdateHyperliquidSpotSniperConfigRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof UpdateHyperliquidSpotSniperConfigRequest["authData"] | undefined, val: UpdateHyperliquidSpotSniperConfigRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.UpdateHyperliquidSpotSniperConfigRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: UpdateHyperliquidSpotSniperConfigRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* hypurr.HyperliquidSpotSniperConfig config = 2; */
        if (message.config)
            HyperliquidSpotSniperConfig.internalBinaryWrite(message.config, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UpdateHyperliquidSpotSniperConfigRequest
 */
export const UpdateHyperliquidSpotSniperConfigRequest = new UpdateHyperliquidSpotSniperConfigRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateHyperliquidSpotSniperConfigResponse$Type extends MessageType<UpdateHyperliquidSpotSniperConfigResponse> {
    constructor() {
        super("hypurr.UpdateHyperliquidSpotSniperConfigResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateHyperliquidSpotSniperConfigResponse>): UpdateHyperliquidSpotSniperConfigResponse {
        const message = { success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateHyperliquidSpotSniperConfigResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateHyperliquidSpotSniperConfigResponse): UpdateHyperliquidSpotSniperConfigResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateHyperliquidSpotSniperConfigResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UpdateHyperliquidSpotSniperConfigResponse
 */
export const UpdateHyperliquidSpotSniperConfigResponse = new UpdateHyperliquidSpotSniperConfigResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidWalletSpotTwapSessionsRequest$Type extends MessageType<HyperliquidWalletSpotTwapSessionsRequest> {
    constructor() {
        super("hypurr.HyperliquidWalletSpotTwapSessionsRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidWalletSpotTwapSessionsRequest>): HyperliquidWalletSpotTwapSessionsRequest {
        const message = { authData: {}, walletId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidWalletSpotTwapSessionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidWalletSpotTwapSessionsRequest): HyperliquidWalletSpotTwapSessionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 wallet_id */ 2:
                    message.walletId = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: HyperliquidWalletSpotTwapSessionsRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof HyperliquidWalletSpotTwapSessionsRequest["authData"] | undefined, val: HyperliquidWalletSpotTwapSessionsRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.HyperliquidWalletSpotTwapSessionsRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: HyperliquidWalletSpotTwapSessionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 wallet_id = 2; */
        if (message.walletId !== 0)
            writer.tag(2, WireType.Varint).int64(message.walletId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidWalletSpotTwapSessionsRequest
 */
export const HyperliquidWalletSpotTwapSessionsRequest = new HyperliquidWalletSpotTwapSessionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidWalletSpotTwapSessionsResponse$Type extends MessageType<HyperliquidWalletSpotTwapSessionsResponse> {
    constructor() {
        super("hypurr.HyperliquidWalletSpotTwapSessionsResponse", [
            { no: 1, name: "sessions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWalletSpotTwapSession }
        ]);
    }
    create(value?: PartialMessage<HyperliquidWalletSpotTwapSessionsResponse>): HyperliquidWalletSpotTwapSessionsResponse {
        const message = { sessions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidWalletSpotTwapSessionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidWalletSpotTwapSessionsResponse): HyperliquidWalletSpotTwapSessionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.HyperliquidWalletSpotTwapSession sessions */ 1:
                    message.sessions.push(HyperliquidWalletSpotTwapSession.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidWalletSpotTwapSessionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.HyperliquidWalletSpotTwapSession sessions = 1; */
        for (let i = 0; i < message.sessions.length; i++)
            HyperliquidWalletSpotTwapSession.internalBinaryWrite(message.sessions[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidWalletSpotTwapSessionsResponse
 */
export const HyperliquidWalletSpotTwapSessionsResponse = new HyperliquidWalletSpotTwapSessionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchHyperliquidLaunchRequest$Type extends MessageType<LaunchHyperliquidLaunchRequest> {
    constructor() {
        super("hypurr.LaunchHyperliquidLaunchRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "full_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "token_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "media", kind: "scalar", T: 12 /*ScalarType.BYTES*/ },
            { no: 7, name: "media_type", kind: "enum", T: () => ["hypurr.MediaType", MediaType, "MEDIA_TYPE_"] },
            { no: 8, name: "dev_lockup_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 9, name: "initial_purchase_notional", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<LaunchHyperliquidLaunchRequest>): LaunchHyperliquidLaunchRequest {
        const message = { authData: {}, walletId: 0, description: "", fullName: "", tokenName: "", media: new Uint8Array(0), mediaType: 0, devLockupSeconds: 0, initialPurchaseNotional: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LaunchHyperliquidLaunchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchHyperliquidLaunchRequest): LaunchHyperliquidLaunchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 wallet_id */ 2:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string full_name */ 4:
                    message.fullName = reader.string();
                    break;
                case /* string token_name */ 5:
                    message.tokenName = reader.string();
                    break;
                case /* bytes media */ 6:
                    message.media = reader.bytes();
                    break;
                case /* hypurr.MediaType media_type */ 7:
                    message.mediaType = reader.int32();
                    break;
                case /* int64 dev_lockup_seconds */ 8:
                    message.devLockupSeconds = reader.int64().toNumber();
                    break;
                case /* double initial_purchase_notional */ 9:
                    message.initialPurchaseNotional = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: LaunchHyperliquidLaunchRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof LaunchHyperliquidLaunchRequest["authData"] | undefined, val: LaunchHyperliquidLaunchRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.LaunchHyperliquidLaunchRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: LaunchHyperliquidLaunchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 wallet_id = 2; */
        if (message.walletId !== 0)
            writer.tag(2, WireType.Varint).int64(message.walletId);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string full_name = 4; */
        if (message.fullName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fullName);
        /* string token_name = 5; */
        if (message.tokenName !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.tokenName);
        /* bytes media = 6; */
        if (message.media.length)
            writer.tag(6, WireType.LengthDelimited).bytes(message.media);
        /* hypurr.MediaType media_type = 7; */
        if (message.mediaType !== 0)
            writer.tag(7, WireType.Varint).int32(message.mediaType);
        /* int64 dev_lockup_seconds = 8; */
        if (message.devLockupSeconds !== 0)
            writer.tag(8, WireType.Varint).int64(message.devLockupSeconds);
        /* double initial_purchase_notional = 9; */
        if (message.initialPurchaseNotional !== 0)
            writer.tag(9, WireType.Bit64).double(message.initialPurchaseNotional);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.LaunchHyperliquidLaunchRequest
 */
export const LaunchHyperliquidLaunchRequest = new LaunchHyperliquidLaunchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchHyperliquidLaunchResponse$Type extends MessageType<LaunchHyperliquidLaunchResponse> {
    constructor() {
        super("hypurr.LaunchHyperliquidLaunchResponse", [
            { no: 1, name: "launch", kind: "message", T: () => HyperliquidLaunch }
        ]);
    }
    create(value?: PartialMessage<LaunchHyperliquidLaunchResponse>): LaunchHyperliquidLaunchResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LaunchHyperliquidLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchHyperliquidLaunchResponse): LaunchHyperliquidLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.HyperliquidLaunch launch */ 1:
                    message.launch = HyperliquidLaunch.internalBinaryRead(reader, reader.uint32(), options, message.launch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LaunchHyperliquidLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.HyperliquidLaunch launch = 1; */
        if (message.launch)
            HyperliquidLaunch.internalBinaryWrite(message.launch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.LaunchHyperliquidLaunchResponse
 */
export const LaunchHyperliquidLaunchResponse = new LaunchHyperliquidLaunchResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditHyperliquidLaunchRequest$Type extends MessageType<EditHyperliquidLaunchRequest> {
    constructor() {
        super("hypurr.EditHyperliquidLaunchRequest", [
            { no: 1, name: "auth_data", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 2, name: "launch_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "full_name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "media", kind: "message", T: () => BytesValue },
            { no: 6, name: "media_type", kind: "enum", T: () => ["hypurr.MediaType", MediaType, "MEDIA_TYPE_"] },
            { no: 7, name: "dev_lockup_seconds", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<EditHyperliquidLaunchRequest>): EditHyperliquidLaunchRequest {
        const message = { authData: {}, launchId: 0, description: "", fullName: "", mediaType: 0, devLockupSeconds: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditHyperliquidLaunchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditHyperliquidLaunchRequest): EditHyperliquidLaunchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* map<string, string> auth_data */ 1:
                    this.binaryReadMap1(message.authData, reader, options);
                    break;
                case /* int64 launch_id */ 2:
                    message.launchId = reader.int64().toNumber();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string full_name */ 4:
                    message.fullName = reader.string();
                    break;
                case /* google.protobuf.BytesValue media */ 5:
                    message.media = BytesValue.internalBinaryRead(reader, reader.uint32(), options, message.media);
                    break;
                case /* hypurr.MediaType media_type */ 6:
                    message.mediaType = reader.int32();
                    break;
                case /* int64 dev_lockup_seconds */ 7:
                    message.devLockupSeconds = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap1(map: EditHyperliquidLaunchRequest["authData"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof EditHyperliquidLaunchRequest["authData"] | undefined, val: EditHyperliquidLaunchRequest["authData"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for field hypurr.EditHyperliquidLaunchRequest.auth_data");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: EditHyperliquidLaunchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* map<string, string> auth_data = 1; */
        for (let k of Object.keys(message.authData))
            writer.tag(1, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.authData[k]).join();
        /* int64 launch_id = 2; */
        if (message.launchId !== 0)
            writer.tag(2, WireType.Varint).int64(message.launchId);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string full_name = 4; */
        if (message.fullName !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.fullName);
        /* google.protobuf.BytesValue media = 5; */
        if (message.media)
            BytesValue.internalBinaryWrite(message.media, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* hypurr.MediaType media_type = 6; */
        if (message.mediaType !== 0)
            writer.tag(6, WireType.Varint).int32(message.mediaType);
        /* int64 dev_lockup_seconds = 7; */
        if (message.devLockupSeconds !== 0)
            writer.tag(7, WireType.Varint).int64(message.devLockupSeconds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.EditHyperliquidLaunchRequest
 */
export const EditHyperliquidLaunchRequest = new EditHyperliquidLaunchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EditHyperliquidLaunchResponse$Type extends MessageType<EditHyperliquidLaunchResponse> {
    constructor() {
        super("hypurr.EditHyperliquidLaunchResponse", [
            { no: 1, name: "launch", kind: "message", T: () => HyperliquidLaunch }
        ]);
    }
    create(value?: PartialMessage<EditHyperliquidLaunchResponse>): EditHyperliquidLaunchResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EditHyperliquidLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EditHyperliquidLaunchResponse): EditHyperliquidLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.HyperliquidLaunch launch */ 1:
                    message.launch = HyperliquidLaunch.internalBinaryRead(reader, reader.uint32(), options, message.launch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EditHyperliquidLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.HyperliquidLaunch launch = 1; */
        if (message.launch)
            HyperliquidLaunch.internalBinaryWrite(message.launch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.EditHyperliquidLaunchResponse
 */
export const EditHyperliquidLaunchResponse = new EditHyperliquidLaunchResponse$Type();
/**
 * @generated ServiceType for protobuf service hypurr.Telegram
 */
export const Telegram = new ServiceType("hypurr.Telegram", [
    { name: "TelegramUser", options: {}, I: TelegramUserRequest, O: TelegramUserResponse },
    { name: "TelegramUserWallets", options: {}, I: TelegramUserWalletsRequest, O: TelegramUserWalletsResponse },
    { name: "HyperliquidLaunchTrade", options: {}, I: HyperliquidLaunchTradeRequest, O: HyperliquidLaunchTradeResponse },
    { name: "LaunchHyperliquidLaunch", options: {}, I: LaunchHyperliquidLaunchRequest, O: LaunchHyperliquidLaunchResponse },
    { name: "EditHyperliquidLaunch", options: {}, I: EditHyperliquidLaunchRequest, O: EditHyperliquidLaunchResponse },
    { name: "HyperliquidSpotTrade", options: {}, I: HyperliquidSpotTradeRequest, O: HyperliquidSpotTradeResponse },
    { name: "HyperliquidWalletSpotTwapSessions", options: {}, I: HyperliquidWalletSpotTwapSessionsRequest, O: HyperliquidWalletSpotTwapSessionsResponse },
    { name: "HyperliquidSpotSniperConfigs", options: {}, I: HyperliquidSpotSniperConfigsRequest, O: HyperliquidSpotSniperConfigsResponse },
    { name: "CreateHyperliquidSpotSniperConfig", options: {}, I: CreateHyperliquidSpotSniperConfigRequest, O: CreateHyperliquidSpotSniperConfigResponse },
    { name: "DeleteHyperliquidSpotSniperConfig", options: {}, I: DeleteHyperliquidSpotSniperConfigRequest, O: DeleteHyperliquidSpotSniperConfigResponse },
    { name: "UpdateHyperliquidSpotSniperConfig", options: {}, I: UpdateHyperliquidSpotSniperConfigRequest, O: UpdateHyperliquidSpotSniperConfigResponse }
]);
