// @generated by protobuf-ts 2.8.2 with parameter long_type_number
// @generated from protobuf file "hypurr/eoa/eoa_service.proto" (package "eoa", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HyperliquidLaunch } from "../launch";
import { HyperliquidWallet } from "../wallet";
/**
 * @generated from protobuf message eoa.EOASignature
 */
export interface EOASignature {
    /**
     * @generated from protobuf field: string r = 1;
     */
    r: string;
    /**
     * @generated from protobuf field: string s = 2;
     */
    s: string;
    /**
     * @generated from protobuf field: uint32 v = 3;
     */
    v: number;
}
/**
 * @generated from protobuf message eoa.HyperliquidLaunchTradeRequest
 */
export interface HyperliquidLaunchTradeRequest {
    /**
     * @generated from protobuf field: string signature = 1;
     */
    signature: string;
    /**
     * @generated from protobuf field: int64 launch_id = 2;
     */
    launchId: number;
    /**
     * @generated from protobuf field: int64 wallet_id = 3;
     */
    walletId: number;
    /**
     * @generated from protobuf field: eoa.HyperliquidLaunchTradeDirection direction = 4;
     */
    direction: HyperliquidLaunchTradeDirection;
    /**
     * @generated from protobuf field: string amount = 5;
     */
    amount: string;
    /**
     * @generated from protobuf field: string ethereum_address = 6;
     */
    ethereumAddress: string;
    /**
     * @generated from protobuf field: int64 time = 7;
     */
    time: number;
    /**
     * @generated from protobuf field: double max_slippage = 8;
     */
    maxSlippage: number;
}
/**
 * @generated from protobuf message eoa.HyperliquidLaunchTradeResponse
 */
export interface HyperliquidLaunchTradeResponse {
    /**
     * @generated from protobuf field: double base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: double quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
}
/**
 * @generated from protobuf message eoa.HyperliquidSpotTradeRequest
 */
export interface HyperliquidSpotTradeRequest {
    /**
     * @generated from protobuf field: int64 pair_id = 1;
     */
    pairId: number;
    /**
     * @generated from protobuf field: int64 wallet_id = 2;
     */
    walletId: number;
    /**
     * @generated from protobuf field: eoa.HyperliquidLaunchTradeDirection direction = 3;
     */
    direction: HyperliquidLaunchTradeDirection;
    /**
     * @generated from protobuf field: double amount = 4;
     */
    amount: number;
}
/**
 * @generated from protobuf message eoa.HyperliquidSpotTradeResponse
 */
export interface HyperliquidSpotTradeResponse {
    /**
     * @generated from protobuf field: double base_amount = 1;
     */
    baseAmount: number;
    /**
     * @generated from protobuf field: double quote_amount = 2;
     */
    quoteAmount: number;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
    /**
     * @generated from protobuf field: bool success = 4;
     */
    success: boolean;
}
/**
 * @generated from protobuf message eoa.LaunchHyperliquidLaunchRequest
 */
export interface LaunchHyperliquidLaunchRequest {
    /**
     * @generated from protobuf field: string base_asset = 1;
     */
    baseAsset: string;
    /**
     * @generated from protobuf field: string quote_asset = 2;
     */
    quoteAsset: string;
    /**
     * @generated from protobuf field: double amount = 3;
     */
    amount: number;
}
/**
 * @generated from protobuf message eoa.EOAUserAgentChallengeRequest
 */
export interface EOAUserAgentChallengeRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message eoa.EOAUserAgentChallengeResponse
 */
export interface EOAUserAgentChallengeResponse {
    /**
     * @generated from protobuf field: string agent = 1;
     */
    agent: string;
}
/**
 * @generated from protobuf message eoa.EOAUserRequest
 */
export interface EOAUserRequest {
    /**
     * @generated from protobuf field: eoa.EIP712Signature signature = 1;
     */
    signature?: EIP712Signature;
}
/**
 * @generated from protobuf message eoa.EIP712Signature
 */
export interface EIP712Signature {
    /**
     * @generated from protobuf field: string agentAddress = 1;
     */
    agentAddress: string;
    /**
     * @generated from protobuf field: string agentName = 2;
     */
    agentName: string;
    /**
     * @generated from protobuf field: int64 nonce = 3;
     */
    nonce: number;
    /**
     * @generated from protobuf field: string signature = 4;
     */
    signature: string;
}
/**
 * @generated from protobuf message eoa.EOAUserResponse
 */
export interface EOAUserResponse {
    /**
     * @generated from protobuf field: eoa.EOAToken token = 1;
     */
    token?: EOAToken;
    /**
     * @generated from protobuf field: hypurr.HyperliquidWallet wallet = 2;
     */
    wallet?: HyperliquidWallet;
}
/**
 * @generated from protobuf message eoa.EOAToken
 */
export interface EOAToken {
    /**
     * @generated from protobuf field: string secret = 1;
     */
    secret: string;
    /**
     * @generated from protobuf field: int64 expires_at = 2;
     */
    expiresAt: number;
}
/**
 * @generated from protobuf message eoa.PendingHyperliquidLaunchRequest
 */
export interface PendingHyperliquidLaunchRequest {
}
/**
 * @generated from protobuf message eoa.PendingHyperliquidLaunchResponse
 */
export interface PendingHyperliquidLaunchResponse {
    /**
     * @generated from protobuf field: hypurr.HyperliquidLaunch launch = 1;
     */
    launch?: HyperliquidLaunch;
}
/**
 * @generated from protobuf enum eoa.HyperliquidLaunchTradeDirection
 */
export enum HyperliquidLaunchTradeDirection {
    /**
     * @generated from protobuf enum value: BUY = 0;
     */
    BUY = 0,
    /**
     * @generated from protobuf enum value: SELL = 1;
     */
    SELL = 1
}
// @generated message type with reflection information, may provide speed optimized methods
class EOASignature$Type extends MessageType<EOASignature> {
    constructor() {
        super("eoa.EOASignature", [
            { no: 1, name: "r", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "s", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "v", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<EOASignature>): EOASignature {
        const message = { r: "", s: "", v: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOASignature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOASignature): EOASignature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string r */ 1:
                    message.r = reader.string();
                    break;
                case /* string s */ 2:
                    message.s = reader.string();
                    break;
                case /* uint32 v */ 3:
                    message.v = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOASignature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string r = 1; */
        if (message.r !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.r);
        /* string s = 2; */
        if (message.s !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.s);
        /* uint32 v = 3; */
        if (message.v !== 0)
            writer.tag(3, WireType.Varint).uint32(message.v);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOASignature
 */
export const EOASignature = new EOASignature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidLaunchTradeRequest$Type extends MessageType<HyperliquidLaunchTradeRequest> {
    constructor() {
        super("eoa.HyperliquidLaunchTradeRequest", [
            { no: 1, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "launch_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "direction", kind: "enum", T: () => ["eoa.HyperliquidLaunchTradeDirection", HyperliquidLaunchTradeDirection] },
            { no: 5, name: "amount", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "ethereum_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "time", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "max_slippage", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidLaunchTradeRequest>): HyperliquidLaunchTradeRequest {
        const message = { signature: "", launchId: 0, walletId: 0, direction: 0, amount: "", ethereumAddress: "", time: 0, maxSlippage: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidLaunchTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidLaunchTradeRequest): HyperliquidLaunchTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string signature */ 1:
                    message.signature = reader.string();
                    break;
                case /* int64 launch_id */ 2:
                    message.launchId = reader.int64().toNumber();
                    break;
                case /* int64 wallet_id */ 3:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* eoa.HyperliquidLaunchTradeDirection direction */ 4:
                    message.direction = reader.int32();
                    break;
                case /* string amount */ 5:
                    message.amount = reader.string();
                    break;
                case /* string ethereum_address */ 6:
                    message.ethereumAddress = reader.string();
                    break;
                case /* int64 time */ 7:
                    message.time = reader.int64().toNumber();
                    break;
                case /* double max_slippage */ 8:
                    message.maxSlippage = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidLaunchTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string signature = 1; */
        if (message.signature !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.signature);
        /* int64 launch_id = 2; */
        if (message.launchId !== 0)
            writer.tag(2, WireType.Varint).int64(message.launchId);
        /* int64 wallet_id = 3; */
        if (message.walletId !== 0)
            writer.tag(3, WireType.Varint).int64(message.walletId);
        /* eoa.HyperliquidLaunchTradeDirection direction = 4; */
        if (message.direction !== 0)
            writer.tag(4, WireType.Varint).int32(message.direction);
        /* string amount = 5; */
        if (message.amount !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.amount);
        /* string ethereum_address = 6; */
        if (message.ethereumAddress !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.ethereumAddress);
        /* int64 time = 7; */
        if (message.time !== 0)
            writer.tag(7, WireType.Varint).int64(message.time);
        /* double max_slippage = 8; */
        if (message.maxSlippage !== 0)
            writer.tag(8, WireType.Bit64).double(message.maxSlippage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.HyperliquidLaunchTradeRequest
 */
export const HyperliquidLaunchTradeRequest = new HyperliquidLaunchTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidLaunchTradeResponse$Type extends MessageType<HyperliquidLaunchTradeResponse> {
    constructor() {
        super("eoa.HyperliquidLaunchTradeResponse", [
            { no: 1, name: "base_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidLaunchTradeResponse>): HyperliquidLaunchTradeResponse {
        const message = { baseAmount: 0, quoteAmount: 0, message: "", success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidLaunchTradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidLaunchTradeResponse): HyperliquidLaunchTradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double base_amount */ 1:
                    message.baseAmount = reader.double();
                    break;
                case /* double quote_amount */ 2:
                    message.quoteAmount = reader.double();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidLaunchTradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Bit64).double(message.baseAmount);
        /* double quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Bit64).double(message.quoteAmount);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.HyperliquidLaunchTradeResponse
 */
export const HyperliquidLaunchTradeResponse = new HyperliquidLaunchTradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotTradeRequest$Type extends MessageType<HyperliquidSpotTradeRequest> {
    constructor() {
        super("eoa.HyperliquidSpotTradeRequest", [
            { no: 1, name: "pair_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "direction", kind: "enum", T: () => ["eoa.HyperliquidLaunchTradeDirection", HyperliquidLaunchTradeDirection] },
            { no: 4, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotTradeRequest>): HyperliquidSpotTradeRequest {
        const message = { pairId: 0, walletId: 0, direction: 0, amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotTradeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotTradeRequest): HyperliquidSpotTradeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 pair_id */ 1:
                    message.pairId = reader.int64().toNumber();
                    break;
                case /* int64 wallet_id */ 2:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* eoa.HyperliquidLaunchTradeDirection direction */ 3:
                    message.direction = reader.int32();
                    break;
                case /* double amount */ 4:
                    message.amount = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidSpotTradeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 pair_id = 1; */
        if (message.pairId !== 0)
            writer.tag(1, WireType.Varint).int64(message.pairId);
        /* int64 wallet_id = 2; */
        if (message.walletId !== 0)
            writer.tag(2, WireType.Varint).int64(message.walletId);
        /* eoa.HyperliquidLaunchTradeDirection direction = 3; */
        if (message.direction !== 0)
            writer.tag(3, WireType.Varint).int32(message.direction);
        /* double amount = 4; */
        if (message.amount !== 0)
            writer.tag(4, WireType.Bit64).double(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.HyperliquidSpotTradeRequest
 */
export const HyperliquidSpotTradeRequest = new HyperliquidSpotTradeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidSpotTradeResponse$Type extends MessageType<HyperliquidSpotTradeResponse> {
    constructor() {
        super("eoa.HyperliquidSpotTradeResponse", [
            { no: 1, name: "base_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "quote_amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidSpotTradeResponse>): HyperliquidSpotTradeResponse {
        const message = { baseAmount: 0, quoteAmount: 0, message: "", success: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidSpotTradeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidSpotTradeResponse): HyperliquidSpotTradeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double base_amount */ 1:
                    message.baseAmount = reader.double();
                    break;
                case /* double quote_amount */ 2:
                    message.quoteAmount = reader.double();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                case /* bool success */ 4:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidSpotTradeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double base_amount = 1; */
        if (message.baseAmount !== 0)
            writer.tag(1, WireType.Bit64).double(message.baseAmount);
        /* double quote_amount = 2; */
        if (message.quoteAmount !== 0)
            writer.tag(2, WireType.Bit64).double(message.quoteAmount);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        /* bool success = 4; */
        if (message.success !== false)
            writer.tag(4, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.HyperliquidSpotTradeResponse
 */
export const HyperliquidSpotTradeResponse = new HyperliquidSpotTradeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LaunchHyperliquidLaunchRequest$Type extends MessageType<LaunchHyperliquidLaunchRequest> {
    constructor() {
        super("eoa.LaunchHyperliquidLaunchRequest", [
            { no: 1, name: "base_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "quote_asset", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "amount", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<LaunchHyperliquidLaunchRequest>): LaunchHyperliquidLaunchRequest {
        const message = { baseAsset: "", quoteAsset: "", amount: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LaunchHyperliquidLaunchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LaunchHyperliquidLaunchRequest): LaunchHyperliquidLaunchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string base_asset */ 1:
                    message.baseAsset = reader.string();
                    break;
                case /* string quote_asset */ 2:
                    message.quoteAsset = reader.string();
                    break;
                case /* double amount */ 3:
                    message.amount = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LaunchHyperliquidLaunchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string base_asset = 1; */
        if (message.baseAsset !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.baseAsset);
        /* string quote_asset = 2; */
        if (message.quoteAsset !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.quoteAsset);
        /* double amount = 3; */
        if (message.amount !== 0)
            writer.tag(3, WireType.Bit64).double(message.amount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.LaunchHyperliquidLaunchRequest
 */
export const LaunchHyperliquidLaunchRequest = new LaunchHyperliquidLaunchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOAUserAgentChallengeRequest$Type extends MessageType<EOAUserAgentChallengeRequest> {
    constructor() {
        super("eoa.EOAUserAgentChallengeRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EOAUserAgentChallengeRequest>): EOAUserAgentChallengeRequest {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOAUserAgentChallengeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOAUserAgentChallengeRequest): EOAUserAgentChallengeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOAUserAgentChallengeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOAUserAgentChallengeRequest
 */
export const EOAUserAgentChallengeRequest = new EOAUserAgentChallengeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOAUserAgentChallengeResponse$Type extends MessageType<EOAUserAgentChallengeResponse> {
    constructor() {
        super("eoa.EOAUserAgentChallengeResponse", [
            { no: 1, name: "agent", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EOAUserAgentChallengeResponse>): EOAUserAgentChallengeResponse {
        const message = { agent: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOAUserAgentChallengeResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOAUserAgentChallengeResponse): EOAUserAgentChallengeResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string agent */ 1:
                    message.agent = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOAUserAgentChallengeResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string agent = 1; */
        if (message.agent !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.agent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOAUserAgentChallengeResponse
 */
export const EOAUserAgentChallengeResponse = new EOAUserAgentChallengeResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOAUserRequest$Type extends MessageType<EOAUserRequest> {
    constructor() {
        super("eoa.EOAUserRequest", [
            { no: 1, name: "signature", kind: "message", T: () => EIP712Signature }
        ]);
    }
    create(value?: PartialMessage<EOAUserRequest>): EOAUserRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOAUserRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOAUserRequest): EOAUserRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eoa.EIP712Signature signature */ 1:
                    message.signature = EIP712Signature.internalBinaryRead(reader, reader.uint32(), options, message.signature);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOAUserRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eoa.EIP712Signature signature = 1; */
        if (message.signature)
            EIP712Signature.internalBinaryWrite(message.signature, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOAUserRequest
 */
export const EOAUserRequest = new EOAUserRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EIP712Signature$Type extends MessageType<EIP712Signature> {
    constructor() {
        super("eoa.EIP712Signature", [
            { no: 1, name: "agentAddress", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "agentName", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "nonce", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "signature", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<EIP712Signature>): EIP712Signature {
        const message = { agentAddress: "", agentName: "", nonce: 0, signature: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EIP712Signature>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EIP712Signature): EIP712Signature {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string agentAddress */ 1:
                    message.agentAddress = reader.string();
                    break;
                case /* string agentName */ 2:
                    message.agentName = reader.string();
                    break;
                case /* int64 nonce */ 3:
                    message.nonce = reader.int64().toNumber();
                    break;
                case /* string signature */ 4:
                    message.signature = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EIP712Signature, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string agentAddress = 1; */
        if (message.agentAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.agentAddress);
        /* string agentName = 2; */
        if (message.agentName !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.agentName);
        /* int64 nonce = 3; */
        if (message.nonce !== 0)
            writer.tag(3, WireType.Varint).int64(message.nonce);
        /* string signature = 4; */
        if (message.signature !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.signature);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EIP712Signature
 */
export const EIP712Signature = new EIP712Signature$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOAUserResponse$Type extends MessageType<EOAUserResponse> {
    constructor() {
        super("eoa.EOAUserResponse", [
            { no: 1, name: "token", kind: "message", T: () => EOAToken },
            { no: 2, name: "wallet", kind: "message", T: () => HyperliquidWallet }
        ]);
    }
    create(value?: PartialMessage<EOAUserResponse>): EOAUserResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOAUserResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOAUserResponse): EOAUserResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* eoa.EOAToken token */ 1:
                    message.token = EOAToken.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                case /* hypurr.HyperliquidWallet wallet */ 2:
                    message.wallet = HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options, message.wallet);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOAUserResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* eoa.EOAToken token = 1; */
        if (message.token)
            EOAToken.internalBinaryWrite(message.token, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* hypurr.HyperliquidWallet wallet = 2; */
        if (message.wallet)
            HyperliquidWallet.internalBinaryWrite(message.wallet, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOAUserResponse
 */
export const EOAUserResponse = new EOAUserResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EOAToken$Type extends MessageType<EOAToken> {
    constructor() {
        super("eoa.EOAToken", [
            { no: 1, name: "secret", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "expires_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ }
        ]);
    }
    create(value?: PartialMessage<EOAToken>): EOAToken {
        const message = { secret: "", expiresAt: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EOAToken>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EOAToken): EOAToken {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string secret */ 1:
                    message.secret = reader.string();
                    break;
                case /* int64 expires_at */ 2:
                    message.expiresAt = reader.int64().toNumber();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EOAToken, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string secret = 1; */
        if (message.secret !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.secret);
        /* int64 expires_at = 2; */
        if (message.expiresAt !== 0)
            writer.tag(2, WireType.Varint).int64(message.expiresAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.EOAToken
 */
export const EOAToken = new EOAToken$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingHyperliquidLaunchRequest$Type extends MessageType<PendingHyperliquidLaunchRequest> {
    constructor() {
        super("eoa.PendingHyperliquidLaunchRequest", []);
    }
    create(value?: PartialMessage<PendingHyperliquidLaunchRequest>): PendingHyperliquidLaunchRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingHyperliquidLaunchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingHyperliquidLaunchRequest): PendingHyperliquidLaunchRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: PendingHyperliquidLaunchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.PendingHyperliquidLaunchRequest
 */
export const PendingHyperliquidLaunchRequest = new PendingHyperliquidLaunchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PendingHyperliquidLaunchResponse$Type extends MessageType<PendingHyperliquidLaunchResponse> {
    constructor() {
        super("eoa.PendingHyperliquidLaunchResponse", [
            { no: 1, name: "launch", kind: "message", T: () => HyperliquidLaunch }
        ]);
    }
    create(value?: PartialMessage<PendingHyperliquidLaunchResponse>): PendingHyperliquidLaunchResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PendingHyperliquidLaunchResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PendingHyperliquidLaunchResponse): PendingHyperliquidLaunchResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.HyperliquidLaunch launch */ 1:
                    message.launch = HyperliquidLaunch.internalBinaryRead(reader, reader.uint32(), options, message.launch);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PendingHyperliquidLaunchResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.HyperliquidLaunch launch = 1; */
        if (message.launch)
            HyperliquidLaunch.internalBinaryWrite(message.launch, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message eoa.PendingHyperliquidLaunchResponse
 */
export const PendingHyperliquidLaunchResponse = new PendingHyperliquidLaunchResponse$Type();
/**
 * @generated ServiceType for protobuf service eoa.EOA
 */
export const EOA = new ServiceType("eoa.EOA", [
    { name: "EOAUserAgentChallenge", options: {}, I: EOAUserAgentChallengeRequest, O: EOAUserAgentChallengeResponse },
    { name: "EOAUser", options: {}, I: EOAUserRequest, O: EOAUserResponse },
    { name: "PendingHyperliquidLaunch", options: {}, I: PendingHyperliquidLaunchRequest, O: PendingHyperliquidLaunchResponse },
    { name: "HyperliquidLaunchTrade", options: {}, I: HyperliquidLaunchTradeRequest, O: HyperliquidLaunchTradeResponse },
    { name: "HyperliquidSpotTrade", options: {}, I: HyperliquidSpotTradeRequest, O: HyperliquidSpotTradeResponse }
]);
