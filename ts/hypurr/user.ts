// @generated by protobuf-ts 2.8.2 with parameter long_type_number
// @generated from protobuf file "hypurr/user.proto" (package "hypurr", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HyperliquidLaunchFill } from "./launch";
import { HyperliquidWalletMovement } from "./wallet";
import { HyperliquidWalletBalance } from "./wallet";
import { HyperliquidLaunch } from "./launch";
import { HyperliquidWallet } from "./wallet";
/**
 * @generated from protobuf message hypurr.TelegramUser
 */
export interface TelegramUser {
    /**
     * @generated from protobuf field: int64 telegram_id = 1;
     */
    telegramId: number;
    /**
     * @generated from protobuf field: string telegram_username = 2;
     */
    telegramUsername: string;
    /**
     * @generated from protobuf field: double pending_fees = 3;
     */
    pendingFees: number;
    /**
     * @generated from protobuf field: double referral_rewards = 4;
     */
    referralRewards: number;
    /**
     * @generated from protobuf field: string referral_code = 5;
     */
    referralCode: string;
    /**
     * @generated from protobuf field: int64 referral_score = 6;
     */
    referralScore: number;
    /**
     * @generated from protobuf field: int64 referrer_id = 7;
     */
    referrerId: number;
    /**
     * @generated from protobuf field: hypurr.TelegramUserSettings settings = 8;
     */
    settings?: TelegramUserSettings;
    /**
     * @generated from protobuf field: hypurr.HyperliquidWallet wallet = 9;
     */
    wallet?: HyperliquidWallet;
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWallet wallets = 10;
     */
    wallets: HyperliquidWallet[];
    /**
     * @generated from protobuf field: int64 wallet_id = 11;
     */
    walletId: number;
    /**
     * @generated from protobuf field: hypurr.HyperliquidWallet sniper_wallet = 12;
     */
    sniperWallet?: HyperliquidWallet;
    /**
     * @generated from protobuf field: int64 sniper_wallet_id = 13;
     */
    sniperWalletId: number;
    /**
     * @generated from protobuf field: hypurr.HyperliquidWallet dumper_wallet = 14;
     */
    dumperWallet?: HyperliquidWallet;
    /**
     * @generated from protobuf field: int64 dumper_wallet_id = 15;
     */
    dumperWalletId: number;
    /**
     * @generated from protobuf field: int64 reputation_id = 16;
     */
    reputationId: number;
    /**
     * @generated from protobuf field: hypurr.TelegramUserReputation reputation = 17;
     */
    reputation?: TelegramUserReputation;
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidLaunch launches = 18;
     */
    launches: HyperliquidLaunch[];
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWalletBalance balances = 19;
     */
    balances: HyperliquidWalletBalance[];
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWalletMovement movements = 20;
     */
    movements: HyperliquidWalletMovement[];
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidLaunchFill launch_fills = 21;
     */
    launchFills: HyperliquidLaunchFill[];
    /**
     * @generated from protobuf field: repeated hypurr.HyperliquidWalletLabel labels = 22;
     */
    labels: HyperliquidWalletLabel[];
}
/**
 * @generated from protobuf message hypurr.TelegramUserSettings
 */
export interface TelegramUserSettings {
    /**
     * @generated from protobuf field: int32 left_buy = 1;
     */
    leftBuy: number;
    /**
     * @generated from protobuf field: int32 mid_buy = 2;
     */
    midBuy: number;
    /**
     * @generated from protobuf field: int32 right_buy = 3;
     */
    rightBuy: number;
    /**
     * @generated from protobuf field: int32 left_sell = 4;
     */
    leftSell: number;
    /**
     * @generated from protobuf field: int32 mid_sell = 5;
     */
    midSell: number;
    /**
     * @generated from protobuf field: int32 right_sell = 6;
     */
    rightSell: number;
    /**
     * @generated from protobuf field: bool log_trades = 7;
     */
    logTrades: boolean;
    /**
     * @generated from protobuf field: bool hide_small = 8;
     */
    hideSmall: boolean;
    /**
     * @generated from protobuf field: int32 max_slippage = 9;
     */
    maxSlippage: number;
    /**
     * @generated from protobuf field: float tip_amount = 10;
     */
    tipAmount: number;
    /**
     * @generated from protobuf field: bool no_tipping = 11;
     */
    noTipping: boolean;
    /**
     * @generated from protobuf field: bool auto_bridge = 12;
     */
    autoBridge: boolean;
}
/**
 * @generated from protobuf message hypurr.TelegramUserReputation
 */
export interface TelegramUserReputation {
    /**
     * @generated from protobuf field: double hfun_score = 1;
     */
    hfunScore: number;
    /**
     * @generated from protobuf field: double reputation_score = 2;
     */
    reputationScore: number;
}
/**
 * @generated from protobuf message hypurr.HyperliquidWalletLabel
 */
export interface HyperliquidWalletLabel {
    /**
     * @generated from protobuf field: string ethereum_address = 1;
     */
    ethereumAddress: string;
    /**
     * @generated from protobuf field: string label = 2;
     */
    label: string;
}
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUser$Type extends MessageType<TelegramUser> {
    constructor() {
        super("hypurr.TelegramUser", [
            { no: 1, name: "telegram_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 2, name: "telegram_username", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pending_fees", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 4, name: "referral_rewards", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 5, name: "referral_code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "referral_score", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 7, name: "referrer_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 8, name: "settings", kind: "message", T: () => TelegramUserSettings },
            { no: 9, name: "wallet", kind: "message", T: () => HyperliquidWallet },
            { no: 10, name: "wallets", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWallet },
            { no: 11, name: "wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 12, name: "sniper_wallet", kind: "message", T: () => HyperliquidWallet },
            { no: 13, name: "sniper_wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 14, name: "dumper_wallet", kind: "message", T: () => HyperliquidWallet },
            { no: 15, name: "dumper_wallet_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 16, name: "reputation_id", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 17, name: "reputation", kind: "message", T: () => TelegramUserReputation },
            { no: 18, name: "launches", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidLaunch },
            { no: 19, name: "balances", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWalletBalance },
            { no: 20, name: "movements", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWalletMovement },
            { no: 21, name: "launch_fills", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidLaunchFill },
            { no: 22, name: "labels", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => HyperliquidWalletLabel }
        ]);
    }
    create(value?: PartialMessage<TelegramUser>): TelegramUser {
        const message = { telegramId: 0, telegramUsername: "", pendingFees: 0, referralRewards: 0, referralCode: "", referralScore: 0, referrerId: 0, wallets: [], walletId: 0, sniperWalletId: 0, dumperWalletId: 0, reputationId: 0, launches: [], balances: [], movements: [], launchFills: [], labels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUser>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUser): TelegramUser {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 telegram_id */ 1:
                    message.telegramId = reader.int64().toNumber();
                    break;
                case /* string telegram_username */ 2:
                    message.telegramUsername = reader.string();
                    break;
                case /* double pending_fees */ 3:
                    message.pendingFees = reader.double();
                    break;
                case /* double referral_rewards */ 4:
                    message.referralRewards = reader.double();
                    break;
                case /* string referral_code */ 5:
                    message.referralCode = reader.string();
                    break;
                case /* int64 referral_score */ 6:
                    message.referralScore = reader.int64().toNumber();
                    break;
                case /* int64 referrer_id */ 7:
                    message.referrerId = reader.int64().toNumber();
                    break;
                case /* hypurr.TelegramUserSettings settings */ 8:
                    message.settings = TelegramUserSettings.internalBinaryRead(reader, reader.uint32(), options, message.settings);
                    break;
                case /* hypurr.HyperliquidWallet wallet */ 9:
                    message.wallet = HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options, message.wallet);
                    break;
                case /* repeated hypurr.HyperliquidWallet wallets */ 10:
                    message.wallets.push(HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int64 wallet_id */ 11:
                    message.walletId = reader.int64().toNumber();
                    break;
                case /* hypurr.HyperliquidWallet sniper_wallet */ 12:
                    message.sniperWallet = HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options, message.sniperWallet);
                    break;
                case /* int64 sniper_wallet_id */ 13:
                    message.sniperWalletId = reader.int64().toNumber();
                    break;
                case /* hypurr.HyperliquidWallet dumper_wallet */ 14:
                    message.dumperWallet = HyperliquidWallet.internalBinaryRead(reader, reader.uint32(), options, message.dumperWallet);
                    break;
                case /* int64 dumper_wallet_id */ 15:
                    message.dumperWalletId = reader.int64().toNumber();
                    break;
                case /* int64 reputation_id */ 16:
                    message.reputationId = reader.int64().toNumber();
                    break;
                case /* hypurr.TelegramUserReputation reputation */ 17:
                    message.reputation = TelegramUserReputation.internalBinaryRead(reader, reader.uint32(), options, message.reputation);
                    break;
                case /* repeated hypurr.HyperliquidLaunch launches */ 18:
                    message.launches.push(HyperliquidLaunch.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated hypurr.HyperliquidWalletBalance balances */ 19:
                    message.balances.push(HyperliquidWalletBalance.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated hypurr.HyperliquidWalletMovement movements */ 20:
                    message.movements.push(HyperliquidWalletMovement.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated hypurr.HyperliquidLaunchFill launch_fills */ 21:
                    message.launchFills.push(HyperliquidLaunchFill.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated hypurr.HyperliquidWalletLabel labels */ 22:
                    message.labels.push(HyperliquidWalletLabel.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelegramUser, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 telegram_id = 1; */
        if (message.telegramId !== 0)
            writer.tag(1, WireType.Varint).int64(message.telegramId);
        /* string telegram_username = 2; */
        if (message.telegramUsername !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.telegramUsername);
        /* double pending_fees = 3; */
        if (message.pendingFees !== 0)
            writer.tag(3, WireType.Bit64).double(message.pendingFees);
        /* double referral_rewards = 4; */
        if (message.referralRewards !== 0)
            writer.tag(4, WireType.Bit64).double(message.referralRewards);
        /* string referral_code = 5; */
        if (message.referralCode !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.referralCode);
        /* int64 referral_score = 6; */
        if (message.referralScore !== 0)
            writer.tag(6, WireType.Varint).int64(message.referralScore);
        /* int64 referrer_id = 7; */
        if (message.referrerId !== 0)
            writer.tag(7, WireType.Varint).int64(message.referrerId);
        /* hypurr.TelegramUserSettings settings = 8; */
        if (message.settings)
            TelegramUserSettings.internalBinaryWrite(message.settings, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* hypurr.HyperliquidWallet wallet = 9; */
        if (message.wallet)
            HyperliquidWallet.internalBinaryWrite(message.wallet, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidWallet wallets = 10; */
        for (let i = 0; i < message.wallets.length; i++)
            HyperliquidWallet.internalBinaryWrite(message.wallets[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* int64 wallet_id = 11; */
        if (message.walletId !== 0)
            writer.tag(11, WireType.Varint).int64(message.walletId);
        /* hypurr.HyperliquidWallet sniper_wallet = 12; */
        if (message.sniperWallet)
            HyperliquidWallet.internalBinaryWrite(message.sniperWallet, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* int64 sniper_wallet_id = 13; */
        if (message.sniperWalletId !== 0)
            writer.tag(13, WireType.Varint).int64(message.sniperWalletId);
        /* hypurr.HyperliquidWallet dumper_wallet = 14; */
        if (message.dumperWallet)
            HyperliquidWallet.internalBinaryWrite(message.dumperWallet, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* int64 dumper_wallet_id = 15; */
        if (message.dumperWalletId !== 0)
            writer.tag(15, WireType.Varint).int64(message.dumperWalletId);
        /* int64 reputation_id = 16; */
        if (message.reputationId !== 0)
            writer.tag(16, WireType.Varint).int64(message.reputationId);
        /* hypurr.TelegramUserReputation reputation = 17; */
        if (message.reputation)
            TelegramUserReputation.internalBinaryWrite(message.reputation, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidLaunch launches = 18; */
        for (let i = 0; i < message.launches.length; i++)
            HyperliquidLaunch.internalBinaryWrite(message.launches[i], writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidWalletBalance balances = 19; */
        for (let i = 0; i < message.balances.length; i++)
            HyperliquidWalletBalance.internalBinaryWrite(message.balances[i], writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidWalletMovement movements = 20; */
        for (let i = 0; i < message.movements.length; i++)
            HyperliquidWalletMovement.internalBinaryWrite(message.movements[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidLaunchFill launch_fills = 21; */
        for (let i = 0; i < message.launchFills.length; i++)
            HyperliquidLaunchFill.internalBinaryWrite(message.launchFills[i], writer.tag(21, WireType.LengthDelimited).fork(), options).join();
        /* repeated hypurr.HyperliquidWalletLabel labels = 22; */
        for (let i = 0; i < message.labels.length; i++)
            HyperliquidWalletLabel.internalBinaryWrite(message.labels[i], writer.tag(22, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUser
 */
export const TelegramUser = new TelegramUser$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserSettings$Type extends MessageType<TelegramUserSettings> {
    constructor() {
        super("hypurr.TelegramUserSettings", [
            { no: 1, name: "left_buy", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "mid_buy", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "right_buy", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "left_sell", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "mid_sell", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "right_sell", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "log_trades", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 8, name: "hide_small", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "max_slippage", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "tip_amount", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ },
            { no: 11, name: "no_tipping", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 12, name: "auto_bridge", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TelegramUserSettings>): TelegramUserSettings {
        const message = { leftBuy: 0, midBuy: 0, rightBuy: 0, leftSell: 0, midSell: 0, rightSell: 0, logTrades: false, hideSmall: false, maxSlippage: 0, tipAmount: 0, noTipping: false, autoBridge: false };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserSettings>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserSettings): TelegramUserSettings {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 left_buy */ 1:
                    message.leftBuy = reader.int32();
                    break;
                case /* int32 mid_buy */ 2:
                    message.midBuy = reader.int32();
                    break;
                case /* int32 right_buy */ 3:
                    message.rightBuy = reader.int32();
                    break;
                case /* int32 left_sell */ 4:
                    message.leftSell = reader.int32();
                    break;
                case /* int32 mid_sell */ 5:
                    message.midSell = reader.int32();
                    break;
                case /* int32 right_sell */ 6:
                    message.rightSell = reader.int32();
                    break;
                case /* bool log_trades */ 7:
                    message.logTrades = reader.bool();
                    break;
                case /* bool hide_small */ 8:
                    message.hideSmall = reader.bool();
                    break;
                case /* int32 max_slippage */ 9:
                    message.maxSlippage = reader.int32();
                    break;
                case /* float tip_amount */ 10:
                    message.tipAmount = reader.float();
                    break;
                case /* bool no_tipping */ 11:
                    message.noTipping = reader.bool();
                    break;
                case /* bool auto_bridge */ 12:
                    message.autoBridge = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelegramUserSettings, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 left_buy = 1; */
        if (message.leftBuy !== 0)
            writer.tag(1, WireType.Varint).int32(message.leftBuy);
        /* int32 mid_buy = 2; */
        if (message.midBuy !== 0)
            writer.tag(2, WireType.Varint).int32(message.midBuy);
        /* int32 right_buy = 3; */
        if (message.rightBuy !== 0)
            writer.tag(3, WireType.Varint).int32(message.rightBuy);
        /* int32 left_sell = 4; */
        if (message.leftSell !== 0)
            writer.tag(4, WireType.Varint).int32(message.leftSell);
        /* int32 mid_sell = 5; */
        if (message.midSell !== 0)
            writer.tag(5, WireType.Varint).int32(message.midSell);
        /* int32 right_sell = 6; */
        if (message.rightSell !== 0)
            writer.tag(6, WireType.Varint).int32(message.rightSell);
        /* bool log_trades = 7; */
        if (message.logTrades !== false)
            writer.tag(7, WireType.Varint).bool(message.logTrades);
        /* bool hide_small = 8; */
        if (message.hideSmall !== false)
            writer.tag(8, WireType.Varint).bool(message.hideSmall);
        /* int32 max_slippage = 9; */
        if (message.maxSlippage !== 0)
            writer.tag(9, WireType.Varint).int32(message.maxSlippage);
        /* float tip_amount = 10; */
        if (message.tipAmount !== 0)
            writer.tag(10, WireType.Bit32).float(message.tipAmount);
        /* bool no_tipping = 11; */
        if (message.noTipping !== false)
            writer.tag(11, WireType.Varint).bool(message.noTipping);
        /* bool auto_bridge = 12; */
        if (message.autoBridge !== false)
            writer.tag(12, WireType.Varint).bool(message.autoBridge);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserSettings
 */
export const TelegramUserSettings = new TelegramUserSettings$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TelegramUserReputation$Type extends MessageType<TelegramUserReputation> {
    constructor() {
        super("hypurr.TelegramUserReputation", [
            { no: 1, name: "hfun_score", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ },
            { no: 2, name: "reputation_score", kind: "scalar", T: 1 /*ScalarType.DOUBLE*/ }
        ]);
    }
    create(value?: PartialMessage<TelegramUserReputation>): TelegramUserReputation {
        const message = { hfunScore: 0, reputationScore: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TelegramUserReputation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TelegramUserReputation): TelegramUserReputation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* double hfun_score */ 1:
                    message.hfunScore = reader.double();
                    break;
                case /* double reputation_score */ 2:
                    message.reputationScore = reader.double();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TelegramUserReputation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* double hfun_score = 1; */
        if (message.hfunScore !== 0)
            writer.tag(1, WireType.Bit64).double(message.hfunScore);
        /* double reputation_score = 2; */
        if (message.reputationScore !== 0)
            writer.tag(2, WireType.Bit64).double(message.reputationScore);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.TelegramUserReputation
 */
export const TelegramUserReputation = new TelegramUserReputation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HyperliquidWalletLabel$Type extends MessageType<HyperliquidWalletLabel> {
    constructor() {
        super("hypurr.HyperliquidWalletLabel", [
            { no: 1, name: "ethereum_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "label", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HyperliquidWalletLabel>): HyperliquidWalletLabel {
        const message = { ethereumAddress: "", label: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HyperliquidWalletLabel>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HyperliquidWalletLabel): HyperliquidWalletLabel {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string ethereum_address */ 1:
                    message.ethereumAddress = reader.string();
                    break;
                case /* string label */ 2:
                    message.label = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HyperliquidWalletLabel, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string ethereum_address = 1; */
        if (message.ethereumAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.ethereumAddress);
        /* string label = 2; */
        if (message.label !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.label);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.HyperliquidWalletLabel
 */
export const HyperliquidWalletLabel = new HyperliquidWalletLabel$Type();
