// @generated by protobuf-ts 2.8.2 with parameter long_type_number
// @generated from protobuf file "hypurr/evm_service.proto" (package "hypurr", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { UniV2Candle } from "./evm";
import { ERC20ApprovalEvent } from "./evm";
import { ERC20TransferEvent } from "./evm";
import { UniV2Swap } from "./evm";
import { UniV2Pair } from "./evm";
import { ERC20Token } from "./evm";
/**
 * @generated from protobuf message hypurr.ERC20TokenRequest
 */
export interface ERC20TokenRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message hypurr.ERC20TokenResponse
 */
export interface ERC20TokenResponse {
    /**
     * @generated from protobuf field: hypurr.ERC20Token token = 1;
     */
    token?: ERC20Token;
}
/**
 * @generated from protobuf message hypurr.ERC20TokensRequest
 */
export interface ERC20TokensRequest {
    /**
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
}
/**
 * @generated from protobuf message hypurr.ERC20TokensResponse
 */
export interface ERC20TokensResponse {
    /**
     * @generated from protobuf field: repeated hypurr.ERC20Token tokens = 1;
     */
    tokens: ERC20Token[];
    /**
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message hypurr.UniV2PairRequest
 */
export interface UniV2PairRequest {
    /**
     * @generated from protobuf field: string address = 1;
     */
    address: string;
}
/**
 * @generated from protobuf message hypurr.UniV2PairResponse
 */
export interface UniV2PairResponse {
    /**
     * @generated from protobuf field: hypurr.UniV2Pair pair = 1;
     */
    pair?: UniV2Pair;
}
/**
 * @generated from protobuf message hypurr.UniV2PairsRequest
 */
export interface UniV2PairsRequest {
    /**
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
}
/**
 * @generated from protobuf message hypurr.UniV2PairsResponse
 */
export interface UniV2PairsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.UniV2Pair pairs = 1;
     */
    pairs: UniV2Pair[];
    /**
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message hypurr.UniV2SwapRequest
 */
export interface UniV2SwapRequest {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string;
}
/**
 * @generated from protobuf message hypurr.UniV2SwapResponse
 */
export interface UniV2SwapResponse {
    /**
     * @generated from protobuf field: hypurr.UniV2Swap swap = 1;
     */
    swap?: UniV2Swap;
}
/**
 * @generated from protobuf message hypurr.UniV2SwapsRequest
 */
export interface UniV2SwapsRequest {
    /**
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * @generated from protobuf field: optional string pair_address = 3;
     */
    pairAddress?: string;
    /**
     * @generated from protobuf field: optional string sender_address = 4;
     */
    senderAddress?: string;
    /**
     * @generated from protobuf field: optional string receiver_address = 5;
     */
    receiverAddress?: string;
}
/**
 * @generated from protobuf message hypurr.UniV2SwapsResponse
 */
export interface UniV2SwapsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.UniV2Swap swaps = 1;
     */
    swaps: UniV2Swap[];
    /**
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message hypurr.ERC20TransferEventsRequest
 */
export interface ERC20TransferEventsRequest {
    /**
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * @generated from protobuf field: optional string token_address = 3;
     */
    tokenAddress?: string;
    /**
     * @generated from protobuf field: optional string from_address = 4;
     */
    fromAddress?: string;
    /**
     * @generated from protobuf field: optional string to_address = 5;
     */
    toAddress?: string;
}
/**
 * @generated from protobuf message hypurr.ERC20TransferEventsResponse
 */
export interface ERC20TransferEventsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.ERC20TransferEvent events = 1;
     */
    events: ERC20TransferEvent[];
    /**
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message hypurr.ERC20ApprovalEventsRequest
 */
export interface ERC20ApprovalEventsRequest {
    /**
     * @generated from protobuf field: int32 page_size = 1;
     */
    pageSize: number;
    /**
     * @generated from protobuf field: string page_token = 2;
     */
    pageToken: string;
    /**
     * @generated from protobuf field: optional string token_address = 3;
     */
    tokenAddress?: string;
    /**
     * @generated from protobuf field: optional string owner_address = 4;
     */
    ownerAddress?: string;
    /**
     * @generated from protobuf field: optional string spender_address = 5;
     */
    spenderAddress?: string;
}
/**
 * @generated from protobuf message hypurr.ERC20ApprovalEventsResponse
 */
export interface ERC20ApprovalEventsResponse {
    /**
     * @generated from protobuf field: repeated hypurr.ERC20ApprovalEvent events = 1;
     */
    events: ERC20ApprovalEvent[];
    /**
     * @generated from protobuf field: string next_page_token = 2;
     */
    nextPageToken: string;
}
/**
 * @generated from protobuf message hypurr.UniV2CandlesRequest
 */
export interface UniV2CandlesRequest {
    /**
     * @generated from protobuf field: string pair_address = 1;
     */
    pairAddress: string;
    /**
     * @generated from protobuf field: int64 from_timestamp = 2;
     */
    fromTimestamp: number;
    /**
     * @generated from protobuf field: int64 to_timestamp = 3;
     */
    toTimestamp: number;
    /**
     * @generated from protobuf field: string interval = 4;
     */
    interval: string; // e.g. "5m", "1h", "1d"
}
/**
 * @generated from protobuf message hypurr.UniV2CandlesResponse
 */
export interface UniV2CandlesResponse {
    /**
     * @generated from protobuf field: repeated hypurr.UniV2Candle candles = 1;
     */
    candles: UniV2Candle[];
}
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TokenRequest$Type extends MessageType<ERC20TokenRequest> {
    constructor() {
        super("hypurr.ERC20TokenRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TokenRequest>): ERC20TokenRequest {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TokenRequest): ERC20TokenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TokenRequest
 */
export const ERC20TokenRequest = new ERC20TokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TokenResponse$Type extends MessageType<ERC20TokenResponse> {
    constructor() {
        super("hypurr.ERC20TokenResponse", [
            { no: 1, name: "token", kind: "message", T: () => ERC20Token }
        ]);
    }
    create(value?: PartialMessage<ERC20TokenResponse>): ERC20TokenResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TokenResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TokenResponse): ERC20TokenResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.ERC20Token token */ 1:
                    message.token = ERC20Token.internalBinaryRead(reader, reader.uint32(), options, message.token);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TokenResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.ERC20Token token = 1; */
        if (message.token)
            ERC20Token.internalBinaryWrite(message.token, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TokenResponse
 */
export const ERC20TokenResponse = new ERC20TokenResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TokensRequest$Type extends MessageType<ERC20TokensRequest> {
    constructor() {
        super("hypurr.ERC20TokensRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TokensRequest>): ERC20TokensRequest {
        const message = { pageSize: 0, pageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TokensRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TokensRequest): ERC20TokensRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TokensRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TokensRequest
 */
export const ERC20TokensRequest = new ERC20TokensRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TokensResponse$Type extends MessageType<ERC20TokensResponse> {
    constructor() {
        super("hypurr.ERC20TokensResponse", [
            { no: 1, name: "tokens", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ERC20Token },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TokensResponse>): ERC20TokensResponse {
        const message = { tokens: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TokensResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TokensResponse): ERC20TokensResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.ERC20Token tokens */ 1:
                    message.tokens.push(ERC20Token.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TokensResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.ERC20Token tokens = 1; */
        for (let i = 0; i < message.tokens.length; i++)
            ERC20Token.internalBinaryWrite(message.tokens[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TokensResponse
 */
export const ERC20TokensResponse = new ERC20TokensResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2PairRequest$Type extends MessageType<UniV2PairRequest> {
    constructor() {
        super("hypurr.UniV2PairRequest", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2PairRequest>): UniV2PairRequest {
        const message = { address: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2PairRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2PairRequest): UniV2PairRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2PairRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2PairRequest
 */
export const UniV2PairRequest = new UniV2PairRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2PairResponse$Type extends MessageType<UniV2PairResponse> {
    constructor() {
        super("hypurr.UniV2PairResponse", [
            { no: 1, name: "pair", kind: "message", T: () => UniV2Pair }
        ]);
    }
    create(value?: PartialMessage<UniV2PairResponse>): UniV2PairResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2PairResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2PairResponse): UniV2PairResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.UniV2Pair pair */ 1:
                    message.pair = UniV2Pair.internalBinaryRead(reader, reader.uint32(), options, message.pair);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2PairResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.UniV2Pair pair = 1; */
        if (message.pair)
            UniV2Pair.internalBinaryWrite(message.pair, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2PairResponse
 */
export const UniV2PairResponse = new UniV2PairResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2PairsRequest$Type extends MessageType<UniV2PairsRequest> {
    constructor() {
        super("hypurr.UniV2PairsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2PairsRequest>): UniV2PairsRequest {
        const message = { pageSize: 0, pageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2PairsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2PairsRequest): UniV2PairsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2PairsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2PairsRequest
 */
export const UniV2PairsRequest = new UniV2PairsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2PairsResponse$Type extends MessageType<UniV2PairsResponse> {
    constructor() {
        super("hypurr.UniV2PairsResponse", [
            { no: 1, name: "pairs", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UniV2Pair },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2PairsResponse>): UniV2PairsResponse {
        const message = { pairs: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2PairsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2PairsResponse): UniV2PairsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.UniV2Pair pairs */ 1:
                    message.pairs.push(UniV2Pair.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2PairsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.UniV2Pair pairs = 1; */
        for (let i = 0; i < message.pairs.length; i++)
            UniV2Pair.internalBinaryWrite(message.pairs[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2PairsResponse
 */
export const UniV2PairsResponse = new UniV2PairsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2SwapRequest$Type extends MessageType<UniV2SwapRequest> {
    constructor() {
        super("hypurr.UniV2SwapRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2SwapRequest>): UniV2SwapRequest {
        const message = { id: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2SwapRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2SwapRequest): UniV2SwapRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2SwapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2SwapRequest
 */
export const UniV2SwapRequest = new UniV2SwapRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2SwapResponse$Type extends MessageType<UniV2SwapResponse> {
    constructor() {
        super("hypurr.UniV2SwapResponse", [
            { no: 1, name: "swap", kind: "message", T: () => UniV2Swap }
        ]);
    }
    create(value?: PartialMessage<UniV2SwapResponse>): UniV2SwapResponse {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2SwapResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2SwapResponse): UniV2SwapResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* hypurr.UniV2Swap swap */ 1:
                    message.swap = UniV2Swap.internalBinaryRead(reader, reader.uint32(), options, message.swap);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2SwapResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* hypurr.UniV2Swap swap = 1; */
        if (message.swap)
            UniV2Swap.internalBinaryWrite(message.swap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2SwapResponse
 */
export const UniV2SwapResponse = new UniV2SwapResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2SwapsRequest$Type extends MessageType<UniV2SwapsRequest> {
    constructor() {
        super("hypurr.UniV2SwapsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "pair_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "sender_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "receiver_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2SwapsRequest>): UniV2SwapsRequest {
        const message = { pageSize: 0, pageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2SwapsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2SwapsRequest): UniV2SwapsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* optional string pair_address */ 3:
                    message.pairAddress = reader.string();
                    break;
                case /* optional string sender_address */ 4:
                    message.senderAddress = reader.string();
                    break;
                case /* optional string receiver_address */ 5:
                    message.receiverAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2SwapsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* optional string pair_address = 3; */
        if (message.pairAddress !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.pairAddress);
        /* optional string sender_address = 4; */
        if (message.senderAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.senderAddress);
        /* optional string receiver_address = 5; */
        if (message.receiverAddress !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.receiverAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2SwapsRequest
 */
export const UniV2SwapsRequest = new UniV2SwapsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2SwapsResponse$Type extends MessageType<UniV2SwapsResponse> {
    constructor() {
        super("hypurr.UniV2SwapsResponse", [
            { no: 1, name: "swaps", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UniV2Swap },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2SwapsResponse>): UniV2SwapsResponse {
        const message = { swaps: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2SwapsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2SwapsResponse): UniV2SwapsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.UniV2Swap swaps */ 1:
                    message.swaps.push(UniV2Swap.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2SwapsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.UniV2Swap swaps = 1; */
        for (let i = 0; i < message.swaps.length; i++)
            UniV2Swap.internalBinaryWrite(message.swaps[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2SwapsResponse
 */
export const UniV2SwapsResponse = new UniV2SwapsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TransferEventsRequest$Type extends MessageType<ERC20TransferEventsRequest> {
    constructor() {
        super("hypurr.ERC20TransferEventsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "from_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "to_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TransferEventsRequest>): ERC20TransferEventsRequest {
        const message = { pageSize: 0, pageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TransferEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TransferEventsRequest): ERC20TransferEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* optional string token_address */ 3:
                    message.tokenAddress = reader.string();
                    break;
                case /* optional string from_address */ 4:
                    message.fromAddress = reader.string();
                    break;
                case /* optional string to_address */ 5:
                    message.toAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TransferEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* optional string token_address = 3; */
        if (message.tokenAddress !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tokenAddress);
        /* optional string from_address = 4; */
        if (message.fromAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.fromAddress);
        /* optional string to_address = 5; */
        if (message.toAddress !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.toAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TransferEventsRequest
 */
export const ERC20TransferEventsRequest = new ERC20TransferEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20TransferEventsResponse$Type extends MessageType<ERC20TransferEventsResponse> {
    constructor() {
        super("hypurr.ERC20TransferEventsResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ERC20TransferEvent },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20TransferEventsResponse>): ERC20TransferEventsResponse {
        const message = { events: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20TransferEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20TransferEventsResponse): ERC20TransferEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.ERC20TransferEvent events */ 1:
                    message.events.push(ERC20TransferEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20TransferEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.ERC20TransferEvent events = 1; */
        for (let i = 0; i < message.events.length; i++)
            ERC20TransferEvent.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20TransferEventsResponse
 */
export const ERC20TransferEventsResponse = new ERC20TransferEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20ApprovalEventsRequest$Type extends MessageType<ERC20ApprovalEventsRequest> {
    constructor() {
        super("hypurr.ERC20ApprovalEventsRequest", [
            { no: 1, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "token_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "owner_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "spender_address", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20ApprovalEventsRequest>): ERC20ApprovalEventsRequest {
        const message = { pageSize: 0, pageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20ApprovalEventsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20ApprovalEventsRequest): ERC20ApprovalEventsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 page_size */ 1:
                    message.pageSize = reader.int32();
                    break;
                case /* string page_token */ 2:
                    message.pageToken = reader.string();
                    break;
                case /* optional string token_address */ 3:
                    message.tokenAddress = reader.string();
                    break;
                case /* optional string owner_address */ 4:
                    message.ownerAddress = reader.string();
                    break;
                case /* optional string spender_address */ 5:
                    message.spenderAddress = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20ApprovalEventsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 page_size = 1; */
        if (message.pageSize !== 0)
            writer.tag(1, WireType.Varint).int32(message.pageSize);
        /* string page_token = 2; */
        if (message.pageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.pageToken);
        /* optional string token_address = 3; */
        if (message.tokenAddress !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.tokenAddress);
        /* optional string owner_address = 4; */
        if (message.ownerAddress !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.ownerAddress);
        /* optional string spender_address = 5; */
        if (message.spenderAddress !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.spenderAddress);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20ApprovalEventsRequest
 */
export const ERC20ApprovalEventsRequest = new ERC20ApprovalEventsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ERC20ApprovalEventsResponse$Type extends MessageType<ERC20ApprovalEventsResponse> {
    constructor() {
        super("hypurr.ERC20ApprovalEventsResponse", [
            { no: 1, name: "events", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => ERC20ApprovalEvent },
            { no: 2, name: "next_page_token", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ERC20ApprovalEventsResponse>): ERC20ApprovalEventsResponse {
        const message = { events: [], nextPageToken: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ERC20ApprovalEventsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ERC20ApprovalEventsResponse): ERC20ApprovalEventsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.ERC20ApprovalEvent events */ 1:
                    message.events.push(ERC20ApprovalEvent.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* string next_page_token */ 2:
                    message.nextPageToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ERC20ApprovalEventsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.ERC20ApprovalEvent events = 1; */
        for (let i = 0; i < message.events.length; i++)
            ERC20ApprovalEvent.internalBinaryWrite(message.events[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* string next_page_token = 2; */
        if (message.nextPageToken !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.nextPageToken);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.ERC20ApprovalEventsResponse
 */
export const ERC20ApprovalEventsResponse = new ERC20ApprovalEventsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2CandlesRequest$Type extends MessageType<UniV2CandlesRequest> {
    constructor() {
        super("hypurr.UniV2CandlesRequest", [
            { no: 1, name: "pair_address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 3, name: "to_timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 2 /*LongType.NUMBER*/ },
            { no: 4, name: "interval", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<UniV2CandlesRequest>): UniV2CandlesRequest {
        const message = { pairAddress: "", fromTimestamp: 0, toTimestamp: 0, interval: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2CandlesRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2CandlesRequest): UniV2CandlesRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string pair_address */ 1:
                    message.pairAddress = reader.string();
                    break;
                case /* int64 from_timestamp */ 2:
                    message.fromTimestamp = reader.int64().toNumber();
                    break;
                case /* int64 to_timestamp */ 3:
                    message.toTimestamp = reader.int64().toNumber();
                    break;
                case /* string interval */ 4:
                    message.interval = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2CandlesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string pair_address = 1; */
        if (message.pairAddress !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.pairAddress);
        /* int64 from_timestamp = 2; */
        if (message.fromTimestamp !== 0)
            writer.tag(2, WireType.Varint).int64(message.fromTimestamp);
        /* int64 to_timestamp = 3; */
        if (message.toTimestamp !== 0)
            writer.tag(3, WireType.Varint).int64(message.toTimestamp);
        /* string interval = 4; */
        if (message.interval !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.interval);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2CandlesRequest
 */
export const UniV2CandlesRequest = new UniV2CandlesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UniV2CandlesResponse$Type extends MessageType<UniV2CandlesResponse> {
    constructor() {
        super("hypurr.UniV2CandlesResponse", [
            { no: 1, name: "candles", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => UniV2Candle }
        ]);
    }
    create(value?: PartialMessage<UniV2CandlesResponse>): UniV2CandlesResponse {
        const message = { candles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UniV2CandlesResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UniV2CandlesResponse): UniV2CandlesResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated hypurr.UniV2Candle candles */ 1:
                    message.candles.push(UniV2Candle.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UniV2CandlesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated hypurr.UniV2Candle candles = 1; */
        for (let i = 0; i < message.candles.length; i++)
            UniV2Candle.internalBinaryWrite(message.candles[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message hypurr.UniV2CandlesResponse
 */
export const UniV2CandlesResponse = new UniV2CandlesResponse$Type();
/**
 * @generated ServiceType for protobuf service hypurr.EVM
 */
export const EVM = new ServiceType("hypurr.EVM", [
    { name: "ERC20Token", options: {}, I: ERC20TokenRequest, O: ERC20TokenResponse },
    { name: "ERC20Tokens", options: {}, I: ERC20TokensRequest, O: ERC20TokensResponse },
    { name: "UniV2Pair", options: {}, I: UniV2PairRequest, O: UniV2PairResponse },
    { name: "UniV2Pairs", options: {}, I: UniV2PairsRequest, O: UniV2PairsResponse },
    { name: "UniV2Swap", options: {}, I: UniV2SwapRequest, O: UniV2SwapResponse },
    { name: "UniV2Swaps", options: {}, I: UniV2SwapsRequest, O: UniV2SwapsResponse },
    { name: "ERC20TransferEvents", options: {}, I: ERC20TransferEventsRequest, O: ERC20TransferEventsResponse },
    { name: "ERC20ApprovalEvents", options: {}, I: ERC20ApprovalEventsRequest, O: ERC20ApprovalEventsResponse },
    { name: "UniV2Candles", options: {}, I: UniV2CandlesRequest, O: UniV2CandlesResponse }
]);
